C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\CyLib.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\
                    -DP8051_Keil_951\Debug/CyLib.lst) OT(0) OJ(.\DP8051_Keil_951\Debug\CyLib.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: CyLib.c
   3          * Version 5.30
   4          *
   5          *  Description:
   6          *   Provides a system API for the clocking, interrupts and watchdog timer.
   7          *
   8          *  Note:
   9          *   Documentation of the API's in this file is located in the
  10          *   System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "CyLib.h"
  20          
  21          
  22          /*******************************************************************************
  23          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  24          * a device reset. It is set from initialize_psoc() at the early initialization
  25          * stage. In case of IAR EW IDE, initialize_psoc() is executed before the data
  26          * sections are initialized. To avoid zeroing, CyResetStatus should be placed
  27          * to the .noinit section.
  28          *******************************************************************************/
  29          CY_NOINIT uint8 CYXDATA CyResetStatus;
  30          
  31          
  32          /* Variable Vdda */
  33          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  38          
  39          
  40          /* Do not use these definitions directly in your application */
  41          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  42          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  43          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  44          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  45          
  46          
  47          /* Function Prototypes */
  48          static uint8 CyUSB_PowerOnCheck(void)  ;
  49          static void CyIMO_SetTrimValue(uint8 freq) ;
  50          static void CyBusClk_Internal_SetDivider(uint16 divider);
  51          
  52          #if(CY_PSOC5)
                  static cySysTickCallback CySysTickCallbacks[CY_SYS_SYST_NUM_OF_CALLBACKS];
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 2   

                  static void CySysTickServiceCallbacks(void);
                  uint32 CySysTickInitVar = 0u;
              #endif  /* (CY_PSOC5) */
  57          
  58          
  59          #if(CY_PSOC3)
  60              CY_ISR_PROTO(IntDefaultHandler);
  61          #endif /* (CY_PSOC3) */
  62          
  63          
  64          /*******************************************************************************
  65          * Function Name: CyPLL_OUT_Start
  66          ********************************************************************************
  67          *
  68          * Summary:
  69          *   Enables the PLL.  Optionally waits for it to become stable.
  70          *   Waits at least 250 us or until it is detected that the PLL is stable.
  71          *
  72          * Parameters:
  73          *   wait:
  74          *    0: Return immediately after configuration
  75          *    1: Wait for PLL lock or timeout.
  76          *
  77          * Return:
  78          *   Status
  79          *    CYRET_SUCCESS - Completed successfully
  80          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  81          *     If the input source of the clock is jittery, then the lock indication
  82          *     may not occur.  However, after the timeout has expired the generated PLL
  83          *     clock can still be used.
  84          *
  85          * Side Effects:
  86          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
  87          *  Any other use of the Fast Time Wheel will be stopped during the period of
  88          *  this function and then restored. This function also uses the 100 KHz ILO.
  89          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  90          *  this function.
  91          *
  92          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  93          *  Once Per Second interrupt may be made by interrupt routines during the period
  94          *  of this function execution. The current operation of the ILO, Central Time
  95          *  Wheel and Once Per Second interrupt are maintained during the operation of
  96          *  this function provided the reading of the Power Manager Interrupt Status
  97          *  Register is only done using the CyPmReadStatus() function.
  98          *
  99          *******************************************************************************/
 100          cystatus CyPLL_OUT_Start(uint8 wait) 
 101          {
 102   1          cystatus status = CYRET_SUCCESS;
 103   1      
 104   1          uint8 iloEnableState;
 105   1          uint8 pmTwCfg0State;
 106   1          uint8 pmTwCfg2State;
 107   1      
 108   1      
 109   1          /* Enables PLL circuit  */
 110   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 111   1      
 112   1          if(wait != 0u)
 113   1          {
 114   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 115   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 3   

 116   2              pmTwCfg0State = CY_LIB_PM_TW_CFG0_REG;
 117   2              pmTwCfg2State = CY_LIB_PM_TW_CFG2_REG;
 118   2      
 119   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 120   2      
 121   2              status = CYRET_TIMEOUT;
 122   2      
 123   2              while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 124   2              {
 125   3                  /* Wait for interrupt status */
 126   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 127   3                  {
 128   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 129   4                      {
 130   5                          status = CYRET_SUCCESS;
 131   5                          break;
 132   5                      }
 133   4                  }
 134   3              }
 135   2      
 136   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 137   2              if(0u == iloEnableState)
 138   2              {
 139   3                  CyILO_Stop100K();
 140   3              }
 141   2      
 142   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0State;
 143   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2State;
 144   2          }
 145   1      
 146   1          return(status);
 147   1      }
 148          
 149          
 150          /*******************************************************************************
 151          * Function Name: CyPLL_OUT_Stop
 152          ********************************************************************************
 153          *
 154          * Summary:
 155          *  Disables the PLL.
 156          *
 157          * Parameters:
 158          *  None
 159          *
 160          * Return:
 161          *  None
 162          *
 163          *******************************************************************************/
 164          void CyPLL_OUT_Stop(void) 
 165          {
 166   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 167   1      }
 168          
 169          
 170          /*******************************************************************************
 171          * Function Name: CyPLL_OUT_SetPQ
 172          ********************************************************************************
 173          *
 174          * Summary:
 175          *  Sets the P and Q dividers and the charge pump current.
 176          *  The Frequency Out will be P/Q * Frequency In.
 177          *  The PLL must be disabled before calling this function.
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 4   

 178          *
 179          * Parameters:
 180          *  uint8 pDiv:
 181          *   Valid range [8 - 255].
 182          *
 183          *  uint8 qDiv:
 184          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 185          
 186          *  uint8 current:
 187          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 188          *   datasheet for more information.
 189          *
 190          * Return:
 191          *  None
 192          *
 193          * Side Effects:
 194          *  If this function execution results in the CPU clock frequency increasing,
 195          *  then the number of clock cycles the cache will wait before it samples data
 196          *  coming back from the Flash must be adjusted by calling
 197          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 198          *  called if the CPU clock frequency is lowered in order to improve the CPU
 199          *  performance. See CyFlash_SetWaitCycles() description for more information.
 200          *
 201          *******************************************************************************/
 202          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 203          {
 204   1          /* Halt CPU in debug mode if PLL is enabled */
 205   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 206   1      
 207   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 208   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 209   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 210   1          {
 211   2              /* Set new values */
 212   2              CY_CLK_PLL_P_REG = pDiv;
 213   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 214   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 215   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 216   2          }
 217   1          else
 218   1          {
 219   2              /***********************************************************************
 220   2              * Halt CPU in debug mode if:
 221   2              * - P divider is less than required
 222   2              * - Q divider is out of range
 223   2              * - pump current is out of range
 224   2              ***********************************************************************/
 225   2              CYASSERT(0u != 0u);
 226   2          }
 227   1      
 228   1      }
 229          
 230          
 231          /*******************************************************************************
 232          * Function Name: CyPLL_OUT_SetSource
 233          ********************************************************************************
 234          *
 235          * Summary:
 236          *  Sets the input clock source to the PLL. The PLL must be disabled before
 237          *  calling this function.
 238          *
 239          * Parameters:
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 5   

 240          *   source: One of the three available PLL clock sources
 241          *    CY_PLL_SOURCE_IMO  :   IMO
 242          *    CY_PLL_SOURCE_XTAL :   MHz Crystal
 243          *    CY_PLL_SOURCE_DSI  :   DSI
 244          *
 245          * Return:
 246          *  None
 247          *
 248          * Side Effects:
 249          *  If this function execution results in the CPU clock frequency increasing,
 250          *  then the number of clock cycles the cache will wait before it samples data
 251          *  coming back from the3 Flash must be adjusted by calling
 252          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 253          *  called if the CPU clock frequency is lowered in order to improve the CPU
 254          *  performance. See CyFlash_SetWaitCycles() description for more information.
 255          *
 256          *******************************************************************************/
 257          void CyPLL_OUT_SetSource(uint8 source) 
 258          {
 259   1          /* Halt CPU in debug mode if PLL is enabled */
 260   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 261   1      
 262   1          switch(source)
 263   1          {
 264   2              case CY_PLL_SOURCE_IMO:
 265   2              case CY_PLL_SOURCE_XTAL:
 266   2              case CY_PLL_SOURCE_DSI:
 267   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 268   2              break;
 269   2      
 270   2              default:
 271   2                  CYASSERT(0u != 0u);
 272   2              break;
 273   2          }
 274   1      }
 275          
 276          
 277          /*******************************************************************************
 278          * Function Name: CyIMO_Start
 279          ********************************************************************************
 280          *
 281          * Summary:
 282          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 283          *
 284          * Parameters:
 285          *  uint8 wait:
 286          *   0: Return immediately after configuration
 287          *   1: Wait for at least 6 us for the IMO to settle.
 288          *
 289          * Return:
 290          *  None
 291          *
 292          * Side Effects:
 293          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
 294          *  Any other use of the Fast Time Wheel will be stopped during the period of
 295          *  this function and then restored. This function also uses the 100 KHz ILO.
 296          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 297          *  this function.
 298          *
 299          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 300          *  Once Per Second interrupt may be made by interrupt routines during the period
 301          *  of this function execution. The current operation of the ILO, Central Time
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 6   

 302          *  Wheel and Once Per Second interrupt are maintained during the operation of
 303          *  this function provided the reading of the Power Manager Interrupt Status
 304          *  Register is only done using the CyPmReadStatus() function.
 305          *
 306          *******************************************************************************/
 307          void CyIMO_Start(uint8 wait) 
 308          {
 309   1          uint8 pmFtwCfg2Reg;
 310   1          uint8 pmFtwCfg0Reg;
 311   1          uint8 ilo100KhzEnable;
 312   1      
 313   1      
 314   1          CY_LIB_PM_ACT_CFG0_REG  |= CY_LIB_PM_ACT_CFG0_IMO_EN;
 315   1          CY_LIB_PM_STBY_CFG0_REG |= CY_LIB_PM_STBY_CFG0_IMO_EN;
 316   1      
 317   1          if(0u != wait)
 318   1          {
 319   2              /* Need to turn on 100KHz ILO if it happens to not already be running.*/
 320   2              ilo100KhzEnable = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 321   2              pmFtwCfg0Reg = CY_LIB_PM_TW_CFG0_REG;
 322   2              pmFtwCfg2Reg = CY_LIB_PM_TW_CFG2_REG;
 323   2      
 324   2              CyPmFtwSetInterval(CY_LIB_CLK_IMO_FTW_TIMEOUT);
 325   2      
 326   2              while (0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 327   2              {
 328   3                  /* Wait for interrupt status */
 329   3              }
 330   2      
 331   2              if(0u == ilo100KhzEnable)
 332   2              {
 333   3                  CyILO_Stop100K();
 334   3              }
 335   2      
 336   2              CY_LIB_PM_TW_CFG0_REG = pmFtwCfg0Reg;
 337   2              CY_LIB_PM_TW_CFG2_REG = pmFtwCfg2Reg;
 338   2          }
 339   1      }
 340          
 341          
 342          /*******************************************************************************
 343          * Function Name: CyIMO_Stop
 344          ********************************************************************************
 345          *
 346          * Summary:
 347          *   Disables the IMO.
 348          *
 349          * Parameters:
 350          *  None
 351          *
 352          * Return:
 353          *  None
 354          *
 355          *******************************************************************************/
 356          void CyIMO_Stop(void) 
 357          {
 358   1          CY_LIB_PM_ACT_CFG0_REG  &= ((uint8) (~CY_LIB_PM_ACT_CFG0_IMO_EN));
 359   1          CY_LIB_PM_STBY_CFG0_REG &= ((uint8) (~CY_LIB_PM_STBY_CFG0_IMO_EN));
 360   1      }
 361          
 362          
 363          /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 7   

 364          * Function Name: CyUSB_PowerOnCheck
 365          ********************************************************************************
 366          *
 367          * Summary:
 368          *  Returns the USB power status value. A private function to cy_boot.
 369          *
 370          * Parameters:
 371          *   None
 372          *
 373          * Return:
 374          *   uint8: one if the USB is enabled, 0 if not enabled.
 375          *
 376          *******************************************************************************/
 377          static uint8 CyUSB_PowerOnCheck(void)  
 378          {
 379   1          uint8 poweredOn = 0u;
 380   1      
 381   1          /* Check whether device is in Active or AltActive and if USB is powered on */
 382   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 383   1             (0u != (CY_LIB_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 384   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 385   1             (0u != (CY_LIB_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 386   1          {
 387   2              poweredOn = 1u;
 388   2          }
 389   1      
 390   1          return (poweredOn);
 391   1      }
 392          
 393          
 394          /*******************************************************************************
 395          * Function Name: CyIMO_SetTrimValue
 396          ********************************************************************************
 397          *
 398          * Summary:
 399          *  Sets the IMO factory trim values.
 400          *
 401          * Parameters:
 402          *  uint8 freq - frequency for which trims must be set
 403          *
 404          * Return:
 405          *  None
 406          *
 407          *******************************************************************************/
 408          static void CyIMO_SetTrimValue(uint8 freq) 
 409          {
 410   1          uint8 usbPowerOn = CyUSB_PowerOnCheck();
 411   1      
 412   1          /* If USB is powered */
 413   1          if(usbPowerOn == 1u)
 414   1          {
 415   2              /* Unlock USB write */
 416   2              CY_LIB_USB_CR1_REG &= ((uint8)(~CY_LIB_USB_CLK_EN));
 417   2          }
 418   1          switch(freq)
 419   1          {
 420   2          case CY_IMO_FREQ_3MHZ:
 421   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_3MHZ_PTR);
 422   2              break;
 423   2      
 424   2          case CY_IMO_FREQ_6MHZ:
 425   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_6MHZ_PTR);
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 8   

 426   2              break;
 427   2      
 428   2          case CY_IMO_FREQ_12MHZ:
 429   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_12MHZ_PTR);
 430   2              break;
 431   2      
 432   2          case CY_IMO_FREQ_24MHZ:
 433   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_24MHZ_PTR);
 434   2              break;
 435   2      
 436   2          case CY_IMO_FREQ_48MHZ:
 437   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_TR1_PTR);
 438   2              break;
 439   2      
 440   2          case CY_IMO_FREQ_62MHZ:
 441   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_67MHZ_PTR);
 442   2              break;
 443   2      
 444   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_80MHZ_PTR);
                      break;
              #endif  /* (CY_PSOC5) */
 449   2      
 450   2          case CY_IMO_FREQ_USB:
 451   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_USB_PTR);
 452   2      
 453   2              /* If USB is powered */
 454   2              if(usbPowerOn == 1u)
 455   2              {
 456   3                  /* Lock USB Oscillator */
 457   3                  CY_LIB_USB_CR1_REG |= CY_LIB_USB_CLK_EN;
 458   3              }
 459   2              break;
 460   2      
 461   2          default:
 462   2                  CYASSERT(0u != 0u);
 463   2              break;
 464   2          }
 465   1      
 466   1      }
 467          
 468          
 469          /*******************************************************************************
 470          * Function Name: CyIMO_SetFreq
 471          ********************************************************************************
 472          *
 473          * Summary:
 474          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 475          *
 476          * Parameters:
 477          *  freq: Frequency of IMO operation
 478          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 479          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 480          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 481          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 482          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 483          *       CY_IMO_FREQ_62MHZ to set 62.6 MHz
 484          *       CY_IMO_FREQ_74MHZ to set 74.7 MHz (not applicable for PSoC 3)
 485          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 486          *
 487          * Return:
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 9   

 488          *  None
 489          *
 490          * Side Effects:
 491          *  If this function execution results in the CPU clock frequency increasing,
 492          *  then the number of clock cycles the cache will wait before it samples data
 493          *  coming back from the Flash must be adjusted by calling
 494          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 495          *  called if the CPU clock frequency is lowered in order to improve the CPU
 496          *  performance. See CyFlash_SetWaitCycles() description for more information.
 497          *
 498          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 499          *  Otherwise this circuit is disabled. The USB block must be powered before
 500          *  selecting the USB setting.
 501          *
 502          *******************************************************************************/
 503          void CyIMO_SetFreq(uint8 freq) 
 504          {
 505   1          uint8 currentFreq;
 506   1          uint8 nextFreq;
 507   1      
 508   1          /***************************************************************************
 509   1          * If the IMO frequency is changed,the Trim values must also be set
 510   1          * accordingly.This requires reading the current frequency. If the new
 511   1          * frequency is faster, then set a new trim and then change the frequency,
 512   1          * otherwise change the frequency and then set new trim values.
 513   1          ***************************************************************************/
 514   1      
 515   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 516   1      
 517   1          /* Check if requested frequency is USB. */
 518   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 519   1      
 520   1          switch (currentFreq)
 521   1          {
 522   2          case 0u:
 523   2              currentFreq = CY_IMO_FREQ_12MHZ;
 524   2              break;
 525   2      
 526   2          case 1u:
 527   2              currentFreq = CY_IMO_FREQ_6MHZ;
 528   2              break;
 529   2      
 530   2          case 2u:
 531   2              currentFreq = CY_IMO_FREQ_24MHZ;
 532   2              break;
 533   2      
 534   2          case 3u:
 535   2              currentFreq = CY_IMO_FREQ_3MHZ;
 536   2              break;
 537   2      
 538   2          case 4u:
 539   2              currentFreq = CY_IMO_FREQ_48MHZ;
 540   2              break;
 541   2      
 542   2          case 5u:
 543   2              currentFreq = CY_IMO_FREQ_62MHZ;
 544   2              break;
 545   2      
 546   2      #if(CY_PSOC5)
                  case 6u:
                      currentFreq = CY_IMO_FREQ_74MHZ;
                      break;
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 10  

              #endif  /* (CY_PSOC5) */
 551   2      
 552   2          default:
 553   2              CYASSERT(0u != 0u);
 554   2              break;
 555   2          }
 556   1      
 557   1          if (nextFreq >= currentFreq)
 558   1          {
 559   2              /* Set new trim first */
 560   2              CyIMO_SetTrimValue(freq);
 561   2          }
 562   1      
 563   1          /* Set usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 564   1          switch(freq)
 565   1          {
 566   2          case CY_IMO_FREQ_3MHZ:
 567   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 568   2                  CY_LIB_IMO_3MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 569   2              break;
 570   2      
 571   2          case CY_IMO_FREQ_6MHZ:
 572   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 573   2                  CY_LIB_IMO_6MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 574   2              break;
 575   2      
 576   2          case CY_IMO_FREQ_12MHZ:
 577   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 578   2                  CY_LIB_IMO_12MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 579   2              break;
 580   2      
 581   2          case CY_IMO_FREQ_24MHZ:
 582   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 583   2                  CY_LIB_IMO_24MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 584   2              break;
 585   2      
 586   2          case CY_IMO_FREQ_48MHZ:
 587   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 588   2                  CY_LIB_IMO_48MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 589   2              break;
 590   2      
 591   2          case CY_IMO_FREQ_62MHZ:
 592   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 593   2                  CY_LIB_IMO_62MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 594   2              break;
 595   2      
 596   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
                          CY_LIB_IMO_74MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
                      break;
              #endif  /* (CY_PSOC5) */
 602   2      
 603   2          case CY_IMO_FREQ_USB:
 604   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 605   2                  CY_LIB_IMO_24MHZ_VALUE) | CY_LIB_IMO_USBCLK_ON_SET;
 606   2              break;
 607   2      
 608   2          default:
 609   2              CYASSERT(0u != 0u);
 610   2              break;
 611   2          }
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 11  

 612   1      
 613   1          /* Tu rn onIMO Doubler, if switching to CY_IMO_FREQ_USB */
 614   1          if (freq == CY_IMO_FREQ_USB)
 615   1          {
 616   2              CyIMO_EnableDoubler();
 617   2          }
 618   1          else
 619   1          {
 620   2              CyIMO_DisableDoubler();
 621   2          }
 622   1      
 623   1          if (nextFreq < currentFreq)
 624   1          {
 625   2              /* Set the trim after setting frequency */
 626   2              CyIMO_SetTrimValue(freq);
 627   2          }
 628   1      }
 629          
 630          
 631          /*******************************************************************************
 632          * Function Name: CyIMO_SetSource
 633          ********************************************************************************
 634          *
 635          * Summary:
 636          *  Sets the source of the clock output from the IMO block.
 637          *
 638          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 639          *  Crystal or DSI input can be the source of the IMO output instead.
 640          *
 641          * Parameters:
 642          *   source: CY_IMO_SOURCE_DSI to set the DSI as source.
 643          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 644          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 645          *
 646          * Return:
 647          *  None
 648          *
 649          * Side Effects:
 650          *  If this function execution resulted in the CPU clock frequency increasing,
 651          *  then the number of clock cycles the cache will wait before it samples data
 652          *  coming back from the Flash must be adjusted by calling
 653          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 654          *  called if the CPU clock frequency is lowered in order to improve the CPU
 655          *  performance. See CyFlash_SetWaitCycles() description for more information.
 656          *
 657          *******************************************************************************/
 658          void CyIMO_SetSource(uint8 source) 
 659          {
 660   1          switch(source)
 661   1          {
 662   2          case CY_IMO_SOURCE_DSI:
 663   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 664   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 665   2              break;
 666   2      
 667   2          case CY_IMO_SOURCE_XTAL:
 668   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 669   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 670   2              break;
 671   2      
 672   2          case CY_IMO_SOURCE_IMO:
 673   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 12  

 674   2              break;
 675   2      
 676   2          default:
 677   2              /* Incorrect source value */
 678   2              CYASSERT(0u != 0u);
 679   2              break;
 680   2          }
 681   1      }
 682          
 683          
 684          /*******************************************************************************
 685          * Function Name: CyIMO_EnableDoubler
 686          ********************************************************************************
 687          *
 688          * Summary:
 689          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 690          *  input to a 48 MHz output for use by the USB block.
 691          *
 692          * Parameters:
 693          *  None
 694          *
 695          * Return:
 696          *  None
 697          *
 698          *******************************************************************************/
 699          void CyIMO_EnableDoubler(void) 
 700          {
 701   1          /* Set FASTCLK_IMO_CR_PTR regigster's 4th bit */
 702   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 703   1      }
 704          
 705          
 706          /*******************************************************************************
 707          * Function Name: CyIMO_DisableDoubler
 708          ********************************************************************************
 709          *
 710          * Summary:
 711          *   Disables the IMO doubler.
 712          *
 713          * Parameters:
 714          *  None
 715          *
 716          * Return:
 717          *  None
 718          *
 719          *******************************************************************************/
 720          void CyIMO_DisableDoubler(void) 
 721          {
 722   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 723   1      }
 724          
 725          
 726          /*******************************************************************************
 727          * Function Name: CyMasterClk_SetSource
 728          ********************************************************************************
 729          *
 730          * Summary:
 731          *  Sets the source of the master clock.
 732          *
 733          * Parameters:
 734          *   source: One of the four available Master clock sources.
 735          *     CY_MASTER_SOURCE_IMO
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 13  

 736          *     CY_MASTER_SOURCE_PLL
 737          *     CY_MASTER_SOURCE_XTAL
 738          *     CY_MASTER_SOURCE_DSI
 739          *
 740          * Return:
 741          *  None
 742          *
 743          * Side Effects:
 744          *  The current source and the new source must both be running and stable before
 745          *  calling this function.
 746          *
 747          *  If this function execution resulted in the CPU clock frequency increasing,
 748          *  then the number of clock cycles the cache will wait before it samples data
 749          *  coming back from the Flash must be adjusted by calling
 750          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 751          *  called if the CPU clock frequency is lowered in order to improve the CPU
 752          *  performance. See CyFlash_SetWaitCycles() description for more information.
 753          *
 754          *******************************************************************************/
 755          void CyMasterClk_SetSource(uint8 source) 
 756          {
 757   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 758   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 759   1      }
 760          
 761          
 762          /*******************************************************************************
 763          * Function Name: CyMasterClk_SetDivider
 764          ********************************************************************************
 765          *
 766          * Summary:
 767          *  Sets the divider value used to generate Master Clock.
 768          *
 769          * Parameters:
 770          *  uint8 divider:
 771          *   The valid range is [0-255]. The clock will be divided by this value + 1.
 772          *   For example to divide this parameter by two should be set to 1.
 773          *
 774          * Return:
 775          *  None
 776          *
 777          * Side Effects:
 778          *  If this function execution resulted in the CPU clock frequency increasing,
 779          *  then the number of clock cycles the cache will wait before it samples data
 780          *  coming back from the Flash must be adjusted by calling
 781          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 782          *  called if the CPU clock frequency is lowered in order to improve the CPU
 783          *  performance. See CyFlash_SetWaitCycles() description for more information.
 784          *
 785          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 786          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 787          *  than the final/expected div-by-1 period.
 788          *
 789          *******************************************************************************/
 790          void CyMasterClk_SetDivider(uint8 divider) 
 791          {
 792   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 793   1      }
 794          
 795          
 796          /*******************************************************************************
 797          * Function Name: CyBusClk_Internal_SetDivider
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 14  

 798          ********************************************************************************
 799          *
 800          * Summary:
 801          *  The function used by CyBusClk_SetDivider(). For internal use only.
 802          *
 803          * Parameters:
 804          *   divider: Valid range [0-65535].
 805          *   The clock will be divided by this value + 1.
 806          *   For example, to divide this parameter by two should be set to 1.
 807          *
 808          * Return:
 809          *  None
 810          *
 811          *******************************************************************************/
 812          static void CyBusClk_Internal_SetDivider(uint16 divider)
 813          {
 814   1          /* Mask bits to enable shadow loads  */
 815   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 816   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 817   1      
 818   1          /* Enable mask bits to enable shadow loads */
 819   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 820   1      
 821   1          /* Update Shadow Divider Value Register with new divider */
 822   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 823   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 824   1      
 825   1      
 826   1          /***************************************************************************
 827   1          * Copy shadow value defined in Shadow Divider Value Register
 828   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 829   1          * dividers selected in Analog and Digital Clock Mask Registers
 830   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 831   1          ***************************************************************************/
 832   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 833   1      }
 834          
 835          
 836          /*******************************************************************************
 837          * Function Name: CyBusClk_SetDivider
 838          ********************************************************************************
 839          *
 840          * Summary:
 841          *  Sets the divider value used to generate the Bus Clock.
 842          *
 843          * Parameters:
 844          *  divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 845          *  For example, to divide this parameter by two should be set to 1.
 846          *
 847          * Return:
 848          *  None
 849          *
 850          * Side Effects:
 851          *  If this function execution resulted in the CPU clock frequency increasing,
 852          *  then the number of clock cycles the cache will wait before it samples data
 853          *  coming back from the Flash must be adjusted by calling
 854          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 855          *  called if the CPU clock frequency is lowered in order to improve the CPU
 856          *  performance. See CyFlash_SetWaitCycles() description for more information.
 857          *
 858          *******************************************************************************/
 859          void CyBusClk_SetDivider(uint16 divider) 
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 15  

 860          {
 861   1          uint8  masterClkDiv;
 862   1          uint16 busClkDiv;
 863   1          uint8 interruptState;
 864   1      
 865   1          interruptState = CyEnterCriticalSection();
 866   1      
 867   1          /* Work around to set bus clock divider value */
 868   1          busClkDiv = (uint16)((uint16)CY_LIB_CLKDIST_BCFG_MSB_REG << 8u);
 869   1          busClkDiv |= CY_LIB_CLKDIST_BCFG_LSB_REG;
 870   1      
 871   1          if ((divider == 0u) || (busClkDiv == 0u))
 872   1          {
 873   2              /* Save away master clock divider value */
 874   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 875   2      
 876   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 877   2              {
 878   3                  /* Set master clock divider to 7 */
 879   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 880   3              }
 881   2      
 882   2              if (divider == 0u)
 883   2              {
 884   3                  /* Set SSS bit and divider register desired value */
 885   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 886   3                  CyBusClk_Internal_SetDivider(divider);
 887   3              }
 888   2              else
 889   2              {
 890   3                  CyBusClk_Internal_SetDivider(divider);
 891   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 892   3              }
 893   2      
 894   2              /* Restore master clock */
 895   2              CyMasterClk_SetDivider(masterClkDiv);
 896   2          }
 897   1          else
 898   1          {
 899   2              CyBusClk_Internal_SetDivider(divider);
 900   2          }
 901   1      
 902   1          CyExitCriticalSection(interruptState);
 903   1      }
 904          
 905          
 906          #if(CY_PSOC3)
 907          
 908              /*******************************************************************************
 909              * Function Name: CyCpuClk_SetDivider
 910              ********************************************************************************
 911              *
 912              * Summary:
 913              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 914              *  PSoC 3 parts.
 915              *
 916              * Parameters:
 917              *  divider: Valid range [0-15]. The clock will be divided by this value + 1.
 918              *  For example, to divide this parameter by two should be set to 1.
 919              *
 920              * Return:
 921              *  None
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 16  

 922              *
 923              * Side Effects:
 924              *  If this function execution resulted in the CPU clock frequency increasing,
 925              *  then the number of clock cycles the cache will wait before it samples data
 926              *  coming back from the Flash must be adjusted by calling
 927              *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 928              *  called if the CPU clock frequency is lowered in order to improve the CPU
 929              *  performance. See CyFlash_SetWaitCycles() description for more information.
 930              *
 931              *******************************************************************************/
 932              void CyCpuClk_SetDivider(uint8 divider) 
 933              {
 934   1                  CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & CY_LIB_CLKDIST_MSTR1_DIV_MASK) |
 935   1                                      ((uint8)(divider << CY_LIB_CLKDIST_DIV_POSITION));
 936   1          }
 937          
 938          #endif /* (CY_PSOC3) */
 939          
 940          
 941          /*******************************************************************************
 942          * Function Name: CyUsbClk_SetSource
 943          ********************************************************************************
 944          *
 945          * Summary:
 946          *  Sets the source of the USB clock.
 947          *
 948          * Parameters:
 949          *  source: One of the four available USB clock sources
 950          *    CY_LIB_USB_CLK_IMO2X     - IMO 2x
 951          *    CY_LIB_USB_CLK_IMO       - IMO
 952          *    CY_LIB_USB_CLK_PLL       - PLL
 953          *    CY_LIB_USB_CLK_DSI       - DSI
 954          *
 955          * Return:
 956          *  None
 957          *
 958          *******************************************************************************/
 959          void CyUsbClk_SetSource(uint8 source) 
 960          {
 961   1          CY_LIB_CLKDIST_UCFG_REG = (CY_LIB_CLKDIST_UCFG_REG & ((uint8)(~CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK))) |
 962   1                              (CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK & source);
 963   1      }
 964          
 965          
 966          /*******************************************************************************
 967          * Function Name: CyILO_Start1K
 968          ********************************************************************************
 969          *
 970          * Summary:
 971          *  Enables the ILO 1 KHz oscillator.
 972          *
 973          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
 974          *  selection in the Clock Editor. Therefore, this API is only needed if the
 975          *  oscillator was turned off manually.
 976          *
 977          * Parameters:
 978          *  None
 979          *
 980          * Return:
 981          *  None
 982          *
 983          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 17  

 984          void CyILO_Start1K(void) 
 985          {
 986   1          /* Set bit 1 of ILO RS */
 987   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ;
 988   1      }
 989          
 990          
 991          /*******************************************************************************
 992          * Function Name: CyILO_Stop1K
 993          ********************************************************************************
 994          *
 995          * Summary:
 996          *  Disables the ILO 1 KHz oscillator.
 997          *
 998          *  Note The ILO 1 KHz oscillator must be enabled if the Sleep or Hibernate low
 999          *  power mode APIs are expected to be used. For more information, refer to the
1000          *  Power Management section of this document.
1001          *
1002          * Parameters:
1003          *  None
1004          *
1005          * Return:
1006          *  None
1007          *
1008          * Side Effects:
1009          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
1010          *
1011          *******************************************************************************/
1012          void CyILO_Stop1K(void) 
1013          {
1014   1          /* Clear bit 1 of ILO RS */
1015   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ));
1016   1      }
1017          
1018          
1019          /*******************************************************************************
1020          * Function Name: CyILO_Start100K
1021          ********************************************************************************
1022          *
1023          * Summary:
1024          *  Enables the ILO 100 KHz oscillator.
1025          *
1026          * Parameters:
1027          *  None
1028          *
1029          * Return:
1030          *  None
1031          *
1032          *******************************************************************************/
1033          void CyILO_Start100K(void) 
1034          {
1035   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
1036   1      }
1037          
1038          
1039          /*******************************************************************************
1040          * Function Name: CyILO_Stop100K
1041          ********************************************************************************
1042          *
1043          * Summary:
1044          *  Disables the ILO 100 KHz oscillator.
1045          *
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 18  

1046          * Parameters:
1047          *  None
1048          *
1049          * Return:
1050          *  None
1051          *
1052          *******************************************************************************/
1053          void CyILO_Stop100K(void) 
1054          {
1055   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ));
1056   1      }
1057          
1058          
1059          /*******************************************************************************
1060          * Function Name: CyILO_Enable33K
1061          ********************************************************************************
1062          *
1063          * Summary:
1064          *  Enables the ILO 33 KHz divider.
1065          *
1066          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
1067          *  so it must also be running in order to generate the 33 KHz output.
1068          *
1069          * Parameters:
1070          *  None
1071          *
1072          * Return:
1073          *  None
1074          *
1075          *******************************************************************************/
1076          void CyILO_Enable33K(void) 
1077          {
1078   1          /* Set bit 5 of ILO RS */
1079   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ;
1080   1      }
1081          
1082          
1083          /*******************************************************************************
1084          * Function Name: CyILO_Disable33K
1085          ********************************************************************************
1086          *
1087          * Summary:
1088          *  Disables the ILO 33 KHz divider.
1089          *
1090          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
1091          *  API does not disable the 100 KHz clock.
1092          *
1093          * Parameters:
1094          *  None
1095          *
1096          * Return:
1097          *  None
1098          *
1099          *******************************************************************************/
1100          void CyILO_Disable33K(void) 
1101          {
1102   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ));
1103   1      }
1104          
1105          
1106          /*******************************************************************************
1107          * Function Name: CyILO_SetSource
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 19  

1108          ********************************************************************************
1109          *
1110          * Summary:
1111          *  Sets the source of the clock output from the ILO block.
1112          *
1113          * Parameters:
1114          *  source: One of the three available ILO output sources
1115          *       Value        Define                Source
1116          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
1117          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
1118          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
1119          *
1120          * Return:
1121          *  None
1122          *
1123          *******************************************************************************/
1124          void CyILO_SetSource(uint8 source) 
1125          {
1126   1          CY_LIB_CLKDIST_CR_REG = (CY_LIB_CLKDIST_CR_REG & CY_ILO_SOURCE_BITS_CLEAR) |
1127   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
1128   1      }
1129          
1130          
1131          /*******************************************************************************
1132          * Function Name: CyILO_SetPowerMode
1133          ********************************************************************************
1134          *
1135          * Summary:
1136          *  Sets the power mode used by the ILO during power down. Allows for lower power
1137          *  down power usage resulting in a slower startup time.
1138          *
1139          * Parameters:
1140          *  uint8 mode
1141          *   CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
1142          *   CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
1143          *
1144          * Return:
1145          *   Prevous power mode state.
1146          *
1147          *******************************************************************************/
1148          uint8 CyILO_SetPowerMode(uint8 mode) 
1149          {
1150   1          uint8 state;
1151   1      
1152   1          /* Get current state. */
1153   1          state = CY_LIB_SLOWCLK_ILO_CR0_REG;
1154   1      
1155   1          /* Set the oscillator power mode. */
1156   1          if(mode != CY_ILO_FAST_START)
1157   1          {
1158   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state | CY_ILO_CONTROL_PD_MODE);
1159   2          }
1160   1          else
1161   1          {
1162   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state & ((uint8)(~CY_ILO_CONTROL_PD_MODE)));
1163   2          }
1164   1      
1165   1          /* Return old mode. */
1166   1          return ((state & CY_ILO_CONTROL_PD_MODE) >> CY_ILO_CONTROL_PD_POSITION);
1167   1      }
1168          
1169          
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 20  

1170          /*******************************************************************************
1171          * Function Name: CyXTAL_32KHZ_Start
1172          ********************************************************************************
1173          *
1174          * Summary:
1175          *  Enables the 32 KHz Crystal Oscillator.
1176          *
1177          * Parameters:
1178          *  None
1179          *
1180          * Return:
1181          *  None
1182          *
1183          *******************************************************************************/
1184          void CyXTAL_32KHZ_Start(void) 
1185          {
1186   1          volatile uint16 i;
1187   1      
1188   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1189   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1190   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1191   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1192   1      
1193   1          #if(CY_PSOC3)
1194   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1195   1          #endif  /* (CY_PSOC3) */
1196   1      
1197   1          /* Enable operation of 32K Crystal Oscillator */
1198   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1199   1      
1200   1          for (i = 1000u; i > 0u; i--)
1201   1          {
1202   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1203   2              {
1204   3                  /* Ready - switch to high power mode */
1205   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1206   3      
1207   3                  break;
1208   3              }
1209   2              CyDelayUs(1u);
1210   2          }
1211   1      }
1212          
1213          
1214          /*******************************************************************************
1215          * Function Name: CyXTAL_32KHZ_Stop
1216          ********************************************************************************
1217          *
1218          * Summary:
1219          *  Disables the 32KHz Crystal Oscillator.
1220          *
1221          * Parameters:
1222          *  None
1223          *
1224          * Return:
1225          *  None
1226          *
1227          *******************************************************************************/
1228          void CyXTAL_32KHZ_Stop(void) 
1229          {
1230   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1231   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 21  

1232   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1233   1                                   CY_CLK_XTAL32_CFG_LP_DEFAULT;
1234   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1235   1      
1236   1          #if(CY_PSOC3)
1237   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1238   1          #endif  /* (CY_PSOC3) */
1239   1      }
1240          
1241          
1242          /*******************************************************************************
1243          * Function Name: CyXTAL_32KHZ_ReadStatus
1244          ********************************************************************************
1245          *
1246          * Summary:
1247          *  Returns status of the 32 KHz oscillator.
1248          *
1249          * Parameters:
1250          *  None
1251          *
1252          * Return:
1253          *  Value     Define                    Source
1254          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1255          *                                       1: Stable
1256          *                                       0: Not stable
1257          *
1258          *******************************************************************************/
1259          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1260          {
1261   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1262   1      }
1263          
1264          
1265          /*******************************************************************************
1266          * Function Name: CyXTAL_32KHZ_SetPowerMode
1267          ********************************************************************************
1268          *
1269          * Summary:
1270          *  Sets the power mode for the 32 KHz oscillator used during the sleep mode.
1271          *  Allows for lower power during sleep when there are fewer sources of noise.
1272          *  During the active mode the oscillator is always run in the high power mode.
1273          *
1274          * Parameters:
1275          *  uint8 mode
1276          *       0: High power mode
1277          *       1: Low power mode during sleep
1278          *
1279          * Return:
1280          *  Previous power mode.
1281          *
1282          *******************************************************************************/
1283          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1284          {
1285   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1286   1      
1287   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1288   1      
1289   1          if(1u == mode)
1290   1          {
1291   2              /* Low power mode during Sleep */
1292   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1293   2              CyDelayUs(10u);
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 22  

1294   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1295   2                                      CY_CLK_XTAL32_CFG_LP_LOWPOWER;
1296   2              CyDelayUs(20u);
1297   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1298   2          }
1299   1          else
1300   1          {
1301   2              /* High power mode */
1302   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1303   2              CyDelayUs(10u);
1304   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1305   2                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1306   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1307   2          }
1308   1      
1309   1          return(state);
1310   1      }
1311          
1312          
1313          /*******************************************************************************
1314          * Function Name: CyXTAL_Start
1315          ********************************************************************************
1316          *
1317          * Summary:
1318          *  Enables the megahertz crystal.
1319          *
1320          *  PSoC 3:
1321          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1322          *  number of milliseconds specified by the wait parameter has expired.
1323          *
1324          * Parameters:
1325          *   wait: Valid range [0-255].
1326          *   This is the timeout value in milliseconds.
1327          *   The appropriate value is crystal specific.
1328          *
1329          * Return:
1330          *   CYRET_SUCCESS - Completed successfully
1331          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1332          *
1333          * Side Effects and Restrictions:
1334          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1335          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1336          *  of this function and then restored.
1337          *
1338          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1339          *  ILO for the period of this function. No changes to the setup of the ILO,
1340          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1341          *  by interrupt routines during the period of this function.
1342          *
1343          *  The current operation of the ILO, Central Timewheel and Once Per Second
1344          *  interrupt are maintained during the operation of this function provided the
1345          *  reading of the Power Manager Interrupt Status Register is only done using the
1346          *  CyPmReadStatus() function.
1347          *
1348          *******************************************************************************/
1349          cystatus CyXTAL_Start(uint8 wait) 
1350          {
1351   1          cystatus status = CYRET_SUCCESS;
1352   1          volatile uint8  timeout = wait;
1353   1          volatile uint8 count;
1354   1          uint8 iloEnableState;
1355   1          uint8 pmTwCfg0Tmp;
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 23  

1356   1          uint8 pmTwCfg2Tmp;
1357   1      
1358   1      
1359   1          /* Enables MHz crystal oscillator circuit  */
1360   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
1361   1      
1362   1      
1363   1          if(wait > 0u)
1364   1          {
1365   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1366   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG;
1367   2              pmTwCfg0Tmp = CY_LIB_PM_TW_CFG0_REG;
1368   2              pmTwCfg2Tmp = CY_LIB_PM_TW_CFG2_REG;
1369   2      
1370   2              /* Set 250 us interval */
1371   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1372   2              status = CYRET_TIMEOUT;
1373   2      
1374   2      
1375   2              for( ; timeout > 0u; timeout--)
1376   2              {
1377   3                  /* Read XERR bit to clear it */
1378   3                  (void) CY_CLK_XMHZ_CSR_REG;
1379   3      
1380   3                  /* Wait for 1 millisecond - 4 x 250 us */
1381   3                  for(count = 4u; count > 0u; count--)
1382   3                  {
1383   4                      while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
1384   4                      {
1385   5                          /* Wait for FTW interrupt event */
1386   5                      }
1387   4                  }
1388   3      
1389   3      
1390   3                  /*******************************************************************
1391   3                  * High output indicates an oscillator failure.
1392   3                  * Only can be used after a start-up interval (1 ms) is completed.
1393   3                  *******************************************************************/
1394   3                  if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1395   3                  {
1396   4                      status = CYRET_SUCCESS;
1397   4                      break;
1398   4                  }
1399   3              }
1400   2      
1401   2      
1402   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1403   2              if(0u == (iloEnableState & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ))
1404   2              {
1405   3                  CyILO_Stop100K();
1406   3              }
1407   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1408   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1409   2          }
1410   1      
1411   1          return(status);
1412   1      }
1413          
1414          
1415          /*******************************************************************************
1416          * Function Name: CyXTAL_Stop
1417          ********************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 24  

1418          *
1419          * Summary:
1420          *  Disables the megahertz crystal oscillator.
1421          *
1422          * Parameters:
1423          *  None
1424          *
1425          * Return:
1426          *  None
1427          *
1428          *******************************************************************************/
1429          void CyXTAL_Stop(void) 
1430          {
1431   1          /* Disable oscillator. */
1432   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1433   1      }
1434          
1435          
1436          /*******************************************************************************
1437          * Function Name: CyXTAL_EnableErrStatus
1438          ********************************************************************************
1439          *
1440          * Summary:
1441          *  Enables the generation of the XERR status bit for the megahertz crystal.
1442          *  This function is not available for PSoC5.
1443          *
1444          * Parameters:
1445          *  None
1446          *
1447          * Return:
1448          *  None
1449          *
1450          *******************************************************************************/
1451          void CyXTAL_EnableErrStatus(void) 
1452          {
1453   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1454   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1455   1      }
1456          
1457          
1458          /*******************************************************************************
1459          * Function Name: CyXTAL_DisableErrStatus
1460          ********************************************************************************
1461          *
1462          * Summary:
1463          *  Disables the generation of the XERR status bit for the megahertz crystal.
1464          *  This function is not available for PSoC5.
1465          *
1466          * Parameters:
1467          *  None
1468          *
1469          * Return:
1470          *  None
1471          *
1472          *******************************************************************************/
1473          void CyXTAL_DisableErrStatus(void) 
1474          {
1475   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1476   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1477   1      }
1478          
1479          
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 25  

1480          /*******************************************************************************
1481          * Function Name: CyXTAL_ReadStatus
1482          ********************************************************************************
1483          *
1484          * Summary:
1485          *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1486          *  sticky, clear on read. This function is not available for PSoC5.
1487          *
1488          * Parameters:
1489          *  None
1490          *
1491          * Return:
1492          *   Status
1493          *    0: No error
1494          *    1: Error
1495          *
1496          *******************************************************************************/
1497          uint8 CyXTAL_ReadStatus(void) 
1498          {
1499   1          /***************************************************************************
1500   1          * High output indicates an oscillator failure. Only use this after a start-up
1501   1          * interval is completed. This can be used for the status and failure recovery.
1502   1          ***************************************************************************/
1503   1          return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1504   1      }
1505          
1506          
1507          /*******************************************************************************
1508          * Function Name: CyXTAL_EnableFaultRecovery
1509          ********************************************************************************
1510          *
1511          * Summary:
1512          *  Enables the fault recovery circuit which will switch to the IMO in the case
1513          *  of a fault in the megahertz crystal circuit. The crystal must be up and
1514          *  running with the XERR bit at 0, before calling this function to prevent
1515          *  an immediate fault switchover. This function is not available for PSoC5.
1516          *
1517          * Parameters:
1518          *  None
1519          *
1520          * Return:
1521          *  None
1522          *
1523          *******************************************************************************/
1524          void CyXTAL_EnableFaultRecovery(void) 
1525          {
1526   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1527   1      }
1528          
1529          
1530          /*******************************************************************************
1531          * Function Name: CyXTAL_DisableFaultRecovery
1532          ********************************************************************************
1533          *
1534          * Summary:
1535          *  Disables the fault recovery circuit which will switch to the IMO in the case
1536          *  of a fault in the megahertz crystal circuit. This function is not available
1537          *  for PSoC5.
1538          *
1539          * Parameters:
1540          *  None
1541          *
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 26  

1542          * Return:
1543          *  None
1544          *
1545          *******************************************************************************/
1546          void CyXTAL_DisableFaultRecovery(void) 
1547          {
1548   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1549   1      }
1550          
1551          
1552          /*******************************************************************************
1553          * Function Name: CyXTAL_SetStartup
1554          ********************************************************************************
1555          *
1556          * Summary:
1557          *  Sets the startup settings for the crystal. The logic model outputs a
1558          *  frequency (setting + 4) MHz when enabled.
1559          *
1560          *  This is artificial as the actual frequency is determined by an attached
1561          *  external crystal.
1562          *
1563          * Parameters:
1564          *  setting: Valid range [0-31].
1565          *   The value is dependent on the frequency and quality of the crystal being
1566          *   used. Refer to the device TRM and datasheet for more information.
1567          *
1568          * Return:
1569          *  None
1570          *
1571          *******************************************************************************/
1572          void CyXTAL_SetStartup(uint8 setting) 
1573          {
1574   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1575   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1576   1      }
1577          
1578          
1579          
1580          /*******************************************************************************
1581          * Function Name: CyXTAL_SetFbVoltage
1582          ********************************************************************************
1583          *
1584          * Summary:
1585          *  Sets the feedback reference voltage to use for the crystal circuit.
1586          *  This function is only available for PSoC3 and PSoC 5LP.
1587          *
1588          * Parameters:
1589          *  setting: Valid range [0-15].
1590          *  Refer to the device TRM and datasheet for more information.
1591          *
1592          * Return:
1593          *  None
1594          *
1595          *******************************************************************************/
1596          void CyXTAL_SetFbVoltage(uint8 setting) 
1597          {
1598   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1599   1                                  (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1600   1      }
1601          
1602          
1603          /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 27  

1604          * Function Name: CyXTAL_SetWdVoltage
1605          ********************************************************************************
1606          *
1607          * Summary:
1608          *  Sets the reference voltage used by the watchdog to detect a failure in the
1609          *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1610          *
1611          * Parameters:
1612          *  setting: Valid range [0-7].
1613          *  Refer to the device TRM and datasheet for more information.
1614          *
1615          * Return:
1616          *  None
1617          *
1618          *******************************************************************************/
1619          void CyXTAL_SetWdVoltage(uint8 setting) 
1620          {
1621   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1622   1                                  (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1623   1      }
1624          
1625          
1626          /*******************************************************************************
1627          * Function Name: CyHalt
1628          ********************************************************************************
1629          *
1630          * Summary:
1631          *  Halts the CPU.
1632          *
1633          * Parameters:
1634          *  uint8 reason: Value to be used during debugging.
1635          *
1636          * Return:
1637          *  None
1638          *
1639          *******************************************************************************/
1640          void CyHalt(uint8 reason) CYREENTRANT
1641          {
1642   1          if(0u != reason)
1643   1          {
1644   2              /* To remove unreferenced local variable warning */
1645   2          }
1646   1      
1647   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__) || defined (__ICCARM__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1652   1              CYDEV_HALT_CPU;
1653   1          #endif  /* (__ARMCC_VERSION) */
1654   1      }
1655          
1656          
1657          /*******************************************************************************
1658          * Function Name: CySoftwareReset
1659          ********************************************************************************
1660          *
1661          * Summary:
1662          *  Forces a device software reset.
1663          *
1664          * Parameters:
1665          *  None
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 28  

1666          *
1667          * Return:
1668          *  None
1669          *
1670          *******************************************************************************/
1671          void CySoftwareReset(void) 
1672          {
1673   1          CY_LIB_RESET_CR2_REG |= CY_LIB_RESET_CR2_RESET;
1674   1      }
1675          
1676          
1677          /*******************************************************************************
1678          * Function Name: CyDelay
1679          ********************************************************************************
1680          *
1681          * Summary:
1682          *  Blocks for milliseconds.
1683          *
1684          *  Note:
1685          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1686          *  the instruction cache is disabled on PSoC5, CyDelay will be two times larger.
1687          *  For example, with instruction cache disabled CyDelay(100) would result in
1688          *  about 200 ms delay instead of 100 ms.
1689          *
1690          * Parameters:
1691          *  milliseconds: number of milliseconds to delay.
1692          *
1693          * Return:
1694          *   None
1695          *
1696          *******************************************************************************/
1697          void CyDelay(uint32 milliseconds) CYREENTRANT
1698          {
1699   1          while (milliseconds > 32768u)
1700   1          {
1701   2              /***********************************************************************
1702   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1703   2              * overflows at about 42 seconds.
1704   2              ***********************************************************************/
1705   2              CyDelayCycles(cydelay_32k_ms);
1706   2              milliseconds = ((uint32)(milliseconds - 32768u));
1707   2          }
1708   1      
1709   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1710   1      }
1711          
1712          
1713          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ********************************************************************************
                  *
                  * Summary:
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 29  

                  *   in about 200us delay instead of 100us.
                  *
                  * Parameters:
                  *  uint16 microseconds: number of microseconds to delay.
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When the instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with the instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1752          
1753          
1754          /*******************************************************************************
1755          * Function Name: CyDelayFreq
1756          ********************************************************************************
1757          *
1758          * Summary:
1759          *  Sets the clock frequency for CyDelay.
1760          *
1761          * Parameters:
1762          *  freq: The frequency of the bus clock in Hertz.
1763          *
1764          * Return:
1765          *  None
1766          *
1767          *******************************************************************************/
1768          void CyDelayFreq(uint32 freq) CYREENTRANT
1769          {
1770   1          if (freq != 0u)
1771   1          {
1772   2              cydelay_freq_hz = freq;
1773   2          }
1774   1          else
1775   1          {
1776   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1777   2          }
1778   1      
1779   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1780   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1781   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1782   1      }
1783          
1784          
1785          /*******************************************************************************
1786          * Function Name: CyWdtStart
1787          ********************************************************************************
1788          *
1789          * Summary:
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 30  

1790          *  Enables the watchdog timer.
1791          *
1792          *  The timer is configured for the specified count interval, the central
1793          *  timewheel is cleared, the setting for the low power mode is configured and
1794          *  the watchdog timer is enabled.
1795          *
1796          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1797          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1798          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1799          *  timer occur. The CTW is free running, so this will occur after between 2 and
1800          *  3 timer periods elapse.
1801          *
1802          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1803          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1804          *  set to be greater than the sleep wakeup period, then feed the dog on each
1805          *  wakeup from Sleep.
1806          *
1807          * Parameters:
1808          *  ticks: One of the four available timer periods. Once WDT enabled, the
1809             interval cannot be changed.
1810          *         CYWDT_2_TICKS     -     4 - 6     ms
1811          *         CYWDT_16_TICKS    -    32 - 48    ms
1812          *         CYWDT_128_TICKS   -   256 - 384   ms
1813          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1814          *
1815          *  lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1816          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1817          *
1818          *          CYWDT_LPMODE_NOCHANGE - No Change
1819          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1820          *                                 mode
1821          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1822          *
1823          * Return:
1824          *  None
1825          *
1826          * Side Effects:
1827          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1828          *  ILO 1 kHz could break the active WDT functionality.
1829          *
1830          *******************************************************************************/
1831          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1832          {
1833   1          /* Set WDT interval */
1834   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1835   1      
1836   1          /* Reset CTW to ensure that first watchdog period is full */
1837   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1838   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1839   1      
1840   1          /* Setting low power mode */
1841   1          CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1842   1                             (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1843   1      
1844   1          /* Enables watchdog reset */
1845   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1846   1      }
1847          
1848          
1849          /*******************************************************************************
1850          * Function Name: CyWdtClear
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 31  

1851          ********************************************************************************
1852          *
1853          * Summary:
1854          *  Clears (feeds) the watchdog timer.
1855          *
1856          * Parameters:
1857          *  None
1858          *
1859          * Return:
1860          *  None
1861          *
1862          *******************************************************************************/
1863          void CyWdtClear(void) 
1864          {
1865   1          CY_WDT_CR_REG = CY_WDT_CR_FEED;
1866   1      }
1867          
1868          
1869          
1870          /*******************************************************************************
1871          * Function Name: CyVdLvDigitEnable
1872          ********************************************************************************
1873          *
1874          * Summary:
1875          *  Sets the voltage trip level, enables the output of the digital low-voltage
1876          *  monitor, and optionally configures voltage monitor to reset device upon the
1877          *  low-voltage event instead of generating an interrupt.
1878          *
1879          *  Note The associated interrupt enable/disable state is not changed by the
1880          *  function. The Interrupt component API should be used to register the
1881          *  interrupt service routine and to enable/disable associated interrupt.
1882          *
1883          * Parameters:
1884          *  reset: Enables device reset on digital low-voltage event:
1885          *   Zero - Interrupt on digital low-voltage event
1886          *   Non-zero - Reset on digital low-voltage event
1887          *
1888          *  threshold: Sets the trip point of the digital low-voltage monitoring circuit
1889          *   in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1890          *   (0x0F). For example, the trip point is set to 1.80 V when the threshold
1891          *   parameter value is 0x04. Refer to the device TRM for the exact trip voltage
1892          *   values.
1893          *
1894          * Return:
1895          *  None
1896          *
1897          * Side Effects and Restrictions:
1898          *  The voltage resets are momentary. When a voltage reset (analog/digital
1899          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1900          *  registers are restored to their default values. This means that the voltage
1901          *  monitor circuit is no longer enabled and the device exits reset. If the
1902          *  supply is below the trip level and firmware enables the voltage reset
1903          *  functionality, the device will reset again. This will continue as long as the
1904          *  supply is below the trip level or as long as the user enables the reset
1905          *  functionality of the voltage monitor functionality.
1906          *
1907          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1908          *  are cleared. This means that analog low-voltage, digital low-voltage and
1909          *  analog high-voltage status bits are not persistent across any voltage reset.
1910          *
1911          *******************************************************************************/
1912          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 32  

1913          {
1914   1          uint32 intRegTmp;
1915   1          uint8 interruptState;
1916   1      
1917   1          interruptState = CyEnterCriticalSection();
1918   1      
1919   1          /* Store interrupt enable state */
1920   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1921   1      
1922   1          /* Disable VD interrupt (write 1) to protect against glitches */
1923   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1924   1      
1925   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1926   1      
1927   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1928   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1929   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1930   1      
1931   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
1932   1          CyDelayUs(1u);
1933   1      
1934   1          (void) CyVdStickyStatus(CY_VD_LVID);
1935   1      
1936   1          if(0u != reset)
1937   1          {
1938   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1939   2          }
1940   1          else
1941   1          {
1942   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1943   2          }
1944   1      
1945   1          /* Clear pending interrupt */
1946   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1947   1      
1948   1          /* Restore interrupt enable state */
1949   1          CY_INT_ENABLE_REG = intRegTmp;
1950   1      
1951   1          CyExitCriticalSection(interruptState);
1952   1      }
1953          
1954          
1955          /*******************************************************************************
1956          * Function Name: CyVdLvAnalogEnable
1957          ********************************************************************************
1958          *
1959          * Summary:
1960          *  Sets the voltage trip level, enables the output of the analog low-voltage
1961          *  monitor, and optionally configures voltage monitor to reset device upon the
1962          *  low-voltage event instead of generating an interrupt.
1963          *
1964          *  Note The associated interrupt enable/disable state is not changed by the
1965          *  function. The Interrupt component API should be used to register the
1966          *  interrupt service routine and to enable/disable associated interrupt.
1967          *
1968          * Parameters:
1969          *  reset: Enables device reset on analog low-voltage event:
1970          *  Zero - Interrupt on analog low-voltage event
1971          *  Non-zero - Reset on analog low-voltage event
1972          *
1973          *  threshold: Sets the trip point of the analog low-voltage monitoring circuit
1974          *  in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 33  

1975          *  (0x0F). For example, the trip point is set to 1.80 V when value of the
1976          *  threshold parameter is 0x04. Please refer to the device TRM for the exact
1977          *  trip voltage values.
1978          *
1979          * Return:
1980          *  None
1981          *
1982          * Side Effects and Restrictions:
1983          *  The voltage resets are momentary. When a voltage reset (analog/digital
1984          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1985          *  registers are restored to their default values. This means that the voltage
1986          *  monitor circuit is no longer enabled and the device exits reset. If the
1987          *  supply is below the trip level and firmware enables the voltage reset
1988          *  functionality, the device will reset again. This will continue as long as
1989          *  the supply is below the trip level or as long as the user enables the reset
1990          *  functionality of the voltage monitor functionality.
1991          *
1992          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1993          *  are cleared. This means that analog low-voltage, digital low-voltage and
1994          *  analog high-voltage status bits are not persistent across any voltage reset.
1995          *
1996          *******************************************************************************/
1997          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
1998          {
1999   1          uint32 intRegTmp;
2000   1          uint8 interruptState;
2001   1      
2002   1          interruptState = CyEnterCriticalSection();
2003   1      
2004   1          /* Store interrupt enable state */
2005   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
2006   1      
2007   1          /* Disable VD interrupt (write 1) to protect against glitches */
2008   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
2009   1      
2010   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2011   1      
2012   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
2013   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
2014   1      
2015   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
2016   1          CyDelayUs(1u);
2017   1      
2018   1          (void) CyVdStickyStatus(CY_VD_LVIA);
2019   1      
2020   1          if(0u != reset)
2021   1          {
2022   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
2023   2          }
2024   1          else
2025   1          {
2026   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2027   2          }
2028   1      
2029   1          /* Clear pending interrupt */
2030   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
2031   1      
2032   1          /* Restore interrupt enable state */
2033   1          CY_INT_ENABLE_REG = intRegTmp;
2034   1      
2035   1          CyExitCriticalSection(interruptState);
2036   1      }
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 34  

2037          
2038          
2039          /*******************************************************************************
2040          * Function Name: CyVdLvDigitDisable
2041          ********************************************************************************
2042          *
2043          * Summary:
2044          *  Disables the digital low-voltage monitor, turns off device reset upon the
2045          *  digital low-voltage event, and clears the associated persistent status bit.
2046          *
2047          *  Note The associated interrupt enable/disable state is not changed by the
2048          *  function. The pending interrupt status is not cleared. The Interrupt
2049          *  component API should be used to manipulate with the associated interrupts.
2050          *
2051          * Parameters:
2052          *  None
2053          *
2054          * Return:
2055          *  None
2056          *
2057          *******************************************************************************/
2058          void CyVdLvDigitDisable(void) 
2059          {
2060   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
2061   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
2062   1          (void) CyVdStickyStatus(CY_VD_LVID);
2063   1      
2064   1          while(0u != (CyVdStickyStatus(CY_VD_LVID) & CY_VD_LVID))
2065   1          {
2066   2      
2067   2          }
2068   1      }
2069          
2070          
2071          /*******************************************************************************
2072          * Function Name: CyVdLvAnalogDisable
2073          ********************************************************************************
2074          *
2075          * Summary:
2076          *  Disables the analog low-voltage monitor, turns off device reset upon the
2077          *  analog low-voltage event, and clears the associated persistent status bit.
2078          *
2079          *  Note The associated interrupt enable/disable state is not changed by the
2080          *  function. The pending interrupt status is not cleared. The Interrupt
2081          *  component API should be used to manipulate with the associated interrupts.
2082          *
2083          * Parameters:
2084          *  None
2085          *
2086          * Return:
2087          *  None
2088          *
2089          *******************************************************************************/
2090          void CyVdLvAnalogDisable(void) 
2091          {
2092   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
2093   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2094   1          while(0u != (CyVdStickyStatus(CY_VD_LVIA) & CY_VD_LVIA))
2095   1          {
2096   2      
2097   2          }
2098   1      }
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 35  

2099          
2100          
2101          /*******************************************************************************
2102          * Function Name: CyVdHvAnalogEnable
2103          ********************************************************************************
2104          *
2105          * Summary:
2106          *  Enables the output of the analog high-voltage monitor and sets 5.75 V
2107          *  threshold detection for Vdda.
2108          *
2109          *  Note The associated interrupt enable/disable state is not changed by the
2110          *  function. The Interrupt component API should be used to register the
2111          *  interrupt service routine and to enable/disable associated interrupt.
2112          *
2113          * Parameters:
2114          *  None
2115          *
2116          * Return:
2117          *  None
2118          *
2119          *******************************************************************************/
2120          void CyVdHvAnalogEnable(void) 
2121          {
2122   1          uint32 intRegTmp;
2123   1          uint8 interruptState;
2124   1      
2125   1          interruptState = CyEnterCriticalSection();
2126   1      
2127   1          /* Store interrupt enable state */
2128   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
2129   1      
2130   1          /* Disable VD interrupt (write 1) to protect against glitches */
2131   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
2132   1      
2133   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2134   1      
2135   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
2136   1      
2137   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling (ID # 127412)  */
2138   1          CyDelayUs(1u);
2139   1      
2140   1          (void) CyVdStickyStatus(CY_VD_HVIA);
2141   1      
2142   1          /* Clear pending interrupt */
2143   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
2144   1      
2145   1          /* Restore interrupt enable state */
2146   1          CY_INT_ENABLE_REG = intRegTmp;
2147   1      
2148   1          CyExitCriticalSection(interruptState);
2149   1      }
2150          
2151          
2152          /*******************************************************************************
2153          * Function Name: CyVdHvAnalogDisable
2154          ********************************************************************************
2155          *
2156          * Summary:
2157          *  Disables the analog high-voltage monitor and clears the associated persistent
2158          *  status bit.
2159          *
2160          *  Note The associated interrupt enable/disable state is not changed by the
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 36  

2161          *  function. The pending interrupt status is not cleared. The Interrupt
2162          *  component API should be used to manipulate with the associated interrupts.
2163          *
2164          * Parameters:
2165          *  None
2166          *
2167          * Return:
2168          *  None
2169          *
2170          *******************************************************************************/
2171          void CyVdHvAnalogDisable(void) 
2172          {
2173   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
2174   1          while(0u != (CyVdStickyStatus(CY_VD_HVIA) & CY_VD_HVIA))
2175   1          {
2176   2      
2177   2          }
2178   1      }
2179          
2180          
2181          /*******************************************************************************
2182          * Function Name: CyVdStickyStatus
2183          ********************************************************************************
2184          *
2185          * Summary:
2186          *  Reads and clears the voltage detection status bits in the RESET_SR0 register.
2187          *  The bits are set to 1 by the voltage monitor circuit when the supply is
2188          *  outside the detector trip point. They stay set to 1 until they are read or
2189          *  a POR / LVI / PRES reset occurs. This function uses a shadow register, so
2190          *  only the bits passed in the parameter will be cleared in the shadow register.
2191          *
2192          * Parameters:
2193          *  mask: Bits in the RESET_SR0 shadow register to clear and return.
2194          *   Define                  Definition
2195          *   CY_VD_LVID            Persistent status of digital LVI.
2196          *   CY_VD_LVIA            Persistent status of analog LVI.
2197          *   CY_VD_HVIA            Persistent status of analog HVI.
2198          *
2199          * Return:
2200          *  Status. Same enumerated bit values as used for the mask parameter. A zero is
2201          *  returned for bits not used in the mask parameter.
2202          *
2203          * Side Effects and Restrictions:
2204          *  When an LVI reset occurs, the RESET_SR0 status registers are cleared. This
2205          *  means that the voltage detection status bits are not persistent across an LVI
2206          *  reset and cannot be used to determine a reset source.
2207          *
2208          *******************************************************************************/
2209          uint8 CyVdStickyStatus(uint8 mask) 
2210          {
2211   1          static uint8 interruptStatus;
2212   1          uint8 interruptState;
2213   1          uint8 tmpStatus;
2214   1      
2215   1          interruptState = CyEnterCriticalSection();
2216   1      
2217   1          interruptStatus |= CY_VD_PERSISTENT_STATUS_REG;
2218   1          tmpStatus = interruptStatus & (uint8)(CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
2219   1          interruptStatus &= ((uint8)(~mask));
2220   1      
2221   1          CyExitCriticalSection(interruptState);
2222   1      
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 37  

2223   1          return(tmpStatus);
2224   1      }
2225          
2226          
2227          /*******************************************************************************
2228          * Function Name: CyVdRealTimeStatus
2229          ********************************************************************************
2230          *
2231          * Summary:
2232          *  Reads the real-time voltage detection status bits in the RESET_SR2 register.
2233          *  The bits are set to 1 by the voltage monitor circuit when the supply is
2234          *  outside the detectors trip point, and set to 0 when the supply is inside the
2235          *  trip point.
2236          *
2237          * Parameters:
2238          *  None
2239          *
2240          * Return:
2241          *  Status of the LVID, LVIA, and HVIA bits in the RESET_SR2 register.
2242          *   Define                  Definition
2243          *   CY_VD_LVID            Real-time status of digital LVI.
2244          *   CY_VD_LVIA            Real-time status of analog LVI.
2245          *   CY_VD_HVIA            Real-time status of analog HVI.
2246          *
2247          * Side Effects and Restrictions:
2248          *  When an LVI reset occurs, the RESET_SR2 status registers are cleared. This
2249          *  means that the voltage detection status bits are not persistent across an LVI
2250          *  reset and cannot be used to determine a reset source.
2251          *
2252          *******************************************************************************/
2253          uint8 CyVdRealTimeStatus(void) 
2254          {
2255   1          uint8 interruptState;
2256   1          uint8 vdFlagsState;
2257   1      
2258   1          interruptState = CyEnterCriticalSection();
2259   1          vdFlagsState = CY_VD_RT_STATUS_REG & (CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
2260   1          CyExitCriticalSection(interruptState);
2261   1      
2262   1          return(vdFlagsState);
2263   1      }
2264          
2265          
2266          /*******************************************************************************
2267          * Function Name: CyDisableInts
2268          ********************************************************************************
2269          *
2270          * Summary:
2271          *  Disables the interrupt enable for each interrupt.
2272          *
2273          * Parameters:
2274          *  None
2275          *
2276          * Return:
2277          *  32 bit mask of previously enabled interrupts.
2278          *
2279          *******************************************************************************/
2280          uint32 CyDisableInts(void) 
2281          {
2282   1          uint32 intState;
2283   1          uint8 interruptState;
2284   1      
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 38  

2285   1          interruptState = CyEnterCriticalSection();
2286   1      
2287   1          #if(CY_PSOC3)
2288   1      
2289   1              /* Get the current interrupt state. */
2290   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
2291   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
2292   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
2293   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
2294   1      
2295   1      
2296   1              /* Disable all of the interrupts. */
2297   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
2298   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
2299   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
2300   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
2301   1      
2302   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2311   1      
2312   1          CyExitCriticalSection(interruptState);
2313   1      
2314   1          return (intState);
2315   1      }
2316          
2317          
2318          /*******************************************************************************
2319          * Function Name: CyEnableInts
2320          ********************************************************************************
2321          *
2322          * Summary:
2323          *  Enables interrupts to a given state.
2324          *
2325          * Parameters:
2326          *  uint32 mask: 32 bit mask of interrupts to enable.
2327          *
2328          * Return:
2329          *  None
2330          *
2331          *******************************************************************************/
2332          void CyEnableInts(uint32 mask) 
2333          {
2334   1      
2335   1          uint8 interruptState;
2336   1      
2337   1          interruptState = CyEnterCriticalSection();
2338   1      
2339   1          #if(CY_PSOC3)
2340   1      
2341   1              /* Set interrupts as enabled. */
2342   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2343   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2344   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2345   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2346   1      
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 39  

2347   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
2352   1      
2353   1          CyExitCriticalSection(interruptState);
2354   1      
2355   1      }
2356          
2357          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ********************************************************************************
                  * Summary:
                  *  Call this API after a flash row erase/write operation to invalidate or flush
                  *  any of that particular flash region content already present in the cache.
                  *  After a cache flush operation, any access to that flash region after the
                  *  erase/write operation would reload the cache with the modified data from the
                  *  flash region. If the flash region update involves multiple flash row write
                  *  operations, then the flushing of the cache can be done once at the end of
                  *  the operation as long as the flash data would not be accessed in the middle
                  *  of the multiple row update process. Else, flush the cache after every flash
                  *  row write.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in cache are invalidated on next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
                      /* Once this is executed it's guaranteed the cache has been flushed */
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 40  

                      (void) CY_CACHE_CONTROL_REG;
              
                      /* Flush the pipeline */
                      CY_SYS_ISB;
              
                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ********************************************************************************
                  * Summary:
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEM_MANAGE_IRQN         - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  *  address: Pointer to an interrupt service routine.
                  *
                  * Return:
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 41  

                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEMORY_MANAGEMENT_IRQN  - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  * Return:
                  *   Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *  address: Pointer to an interrupt service routine
                  *
                  * Return:
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ********************************************************************************
                  *
                  * Summary:
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 42  

                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *
                  * Return:
                  *  The address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 43  

              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ********************************************************************************
                  *
                  * Summary:
                  *   Gets the enable state of the specified interrupt number.
                  *
                  * Parameters:
                  *   number: Valid range [0-31].  Interrupt number.
                  *
                  * Return:
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get pointer to Interrupt enable register. */
                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get state of interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2629          
2630              /*******************************************************************************
2631              * Function Name: IntDefaultHandler
2632              ********************************************************************************
2633              *
2634              * Summary:
2635              *  This function is called for all interrupts, other than a reset that gets
2636              *  called before the system is setup.
2637              *
2638              * Parameters:
2639              *  None
2640              *
2641              * Return:
2642              *  None
2643              *
2644              * Theory:
2645              *  Any value other than zero is acceptable.
2646              *
2647              *******************************************************************************/
2648              CY_ISR(IntDefaultHandler)
2649              {
2650   1              #ifdef CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK
                          CyBoot_IntDefaultHandler_Exception_EntryCallback();
                      #endif /* CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK */
2653   1      
2654   1              while(1)
2655   1              {
2656   2                  /***********************************************************************
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 44  

2657   2                  * We must not get here. If we do, a serious problem occurs, so go
2658   2                  * into an infinite loop.
2659   2                  ***********************************************************************/
2660   2              }
2661   1          }
2662          
2663          
2664              /*******************************************************************************
2665              * Function Name: IntDefaultHandler
2666              ********************************************************************************
2667              *
2668              * Summary:
2669              *  This function is called during startup to initialize interrupt address vector
2670              *  registers with the address of the IntDefaultHandler().
2671              *
2672              * Parameters:
2673              *  None
2674              *
2675              * Return:
2676              *  None
2677              *
2678              *******************************************************************************/
2679              void CyIntInitVectors(void) 
2680              {
2681   1              uint8 i;
2682   1      
2683   1              for (i = 0; i <= CY_INT_NUMBER_MAX; i++)
2684   1              {
2685   2                  CY_SET_REG16(&CY_INT_VECT_TABLE[i], (uint16) &IntDefaultHandler);
2686   2              }
2687   1          }
2688          
2689          
2690              /*******************************************************************************
2691              * Function Name: CyIntSetVector
2692              ********************************************************************************
2693              *
2694              * Summary:
2695              *  Sets the interrupt vector of the specified interrupt number.
2696              *
2697              * Parameters:
2698              *  number:  Valid range [0-31].  Interrupt number
2699              *  address: Pointer to an interrupt service routine
2700              *
2701              * Return:
2702              *  Previous interrupt vector value.
2703              *
2704              *******************************************************************************/
2705              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2706              {
2707   1              cyisraddress oldIsr;
2708   1      
2709   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2710   1      
2711   1              /* Save old Interrupt service routine. */
2712   1              oldIsr = (cyisraddress) \
2713   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2714   1      
2715   1              /* Set new Interrupt service routine. */
2716   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2717   1      
2718   1              return (oldIsr);
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 45  

2719   1          }
2720          
2721          
2722              /*******************************************************************************
2723              * Function Name: CyIntGetVector
2724              ********************************************************************************
2725              *
2726              * Summary:
2727              *  Gets the interrupt vector of the specified interrupt number.
2728              *
2729              * Parameters:
2730              *  number: Valid range [0-31].  Interrupt number
2731              *
2732              * Return:
2733              *  Address of the ISR in the interrupt vector table.
2734              *
2735              *******************************************************************************/
2736              cyisraddress CyIntGetVector(uint8 number) 
2737              {
2738   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2739   1      
2740   1              return ((cyisraddress) \
2741   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2742   1          }
2743          
2744          
2745              /*******************************************************************************
2746              * Function Name: CyIntSetPriority
2747              ********************************************************************************
2748              *
2749              * Summary:
2750              *  Sets the Priority of the Interrupt.
2751              *
2752              * Parameters:
2753              *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2754              *  number:   The number of the interrupt, 0 - 31.
2755              *
2756              * Return:
2757              *  None
2758              *
2759              *******************************************************************************/
2760              void CyIntSetPriority(uint8 number, uint8 priority) 
2761              {
2762   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2763   1      
2764   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2765   1      
2766   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2767   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2768   1          }
2769          
2770          
2771              /*******************************************************************************
2772              * Function Name: CyIntGetPriority
2773              ********************************************************************************
2774              *
2775              * Summary:
2776              *  Gets the Priority of the Interrupt.
2777              *
2778              * Parameters:
2779              *  number: The number of the interrupt, 0 - 31.
2780              *
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 46  

2781              * Return:
2782              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2783              *
2784              *******************************************************************************/
2785              uint8 CyIntGetPriority(uint8 number) 
2786              {
2787   1              uint8 priority;
2788   1      
2789   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2790   1      
2791   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2792   1      
2793   1              return (priority);
2794   1          }
2795          
2796          
2797              /*******************************************************************************
2798              * Function Name: CyIntGetState
2799              ********************************************************************************
2800              *
2801              * Summary:
2802              *   Gets the enable state of the specified interrupt number.
2803              *
2804              * Parameters:
2805              *   number: Valid range [0-31].  Interrupt number.
2806              *
2807              * Return:
2808              *   Enable status: 1 if enabled, 0 if disabled
2809              *
2810              *******************************************************************************/
2811              uint8 CyIntGetState(uint8 number) 
2812              {
2813   1              reg8 * stateReg;
2814   1      
2815   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2816   1      
2817   1              /* Get pointer to Interrupt enable register. */
2818   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2819   1      
2820   1              /* Get state of interrupt. */
2821   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2822   1          }
2823          
2824          #endif  /* (CY_PSOC5) */
2825          
2826          
2827          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  /*******************************************************************************
                  * Function Name: CySetScPumps
                  ********************************************************************************
                  *
                  * Summary:
                  *  If 1 is passed as a parameter:
                  *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                  *     start boost clock.
                  *   - For each enabled SC block set a boost clock index and enable the boost
                  *     clock.
                  *
                  *  If non-1 value is passed as a parameter:
                  *   - If all SC blocks are not used - disable pumps for the SC blocks and
                  *     stop the boost clock.
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 47  

                  *   - For each enabled SC block clear the boost clock index and disable the
                  *     boost clock.
                  *
                  *  The global variable CyScPumpEnabled is updated to be equal to passed the
                  *  parameter.
                  *
                  * Parameters:
                  *   uint8 enable: Enable/disable SC pumps and the boost clock for the enabled
                  *                 SC block:
                  *                 1 - Enable
                  *                 0 - Disable
                  *
                  * Return:
                  *   None
                  *
                  *******************************************************************************/
                  void CySetScPumps(uint8 enable) 
                  {
                      if(1u == enable)
                      {
                          /* The SC pumps should be enabled */
                          CyScPumpEnabled = 1u;
                          /* Enable pumps if any of SC blocks are used */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                          {
                              CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
                              CyScBoostClk_Start();
                          }
                          /* Set positive pump for each enabled SC block: set clock index and enable it */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                          {
                              CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                          {
                              CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                          {
                              CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                          {
                              CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                      }
                      else
                      {
                          /* The SC pumps should be disabled */
                          CyScPumpEnabled = 0u;
                          /* Disable pumps for all SC blocks and stop boost clock */
                          CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                          CyScBoostClk_Stop();
                          /* Disable boost clock and clear clock index for each SC block */
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 48  

                          CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                      }
                  }
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2913          
2914          
2915          #if(CY_PSOC5)
                  /*******************************************************************************
                  * Function Name: CySysTickStart
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the SysTick timer to generate interrupt every 1 ms by call to the
                  *  CySysTickInit() function and starts it by calling CySysTickEnable() function.
                  *  Refer to the corresponding function description for the details.
              
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStart(void)
                  {
                      if (0u == CySysTickInitVar)
                      {
                          CySysTickInit();
                          CySysTickInitVar = 1u;
                      }
              
                      CySysTickEnable();
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickInit
                  ********************************************************************************
                  *
                  * Summary:
                  *  Initializes the callback addresses with pointers to NULL, associates the
                  *  SysTick system vector with the function that is responsible for calling
                  *  registered callback functions, configures SysTick timer to generate interrupt
                  *  every 1 ms.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 49  

                  * Side Effects:
                  *  Clears SysTick count flag if it was set.
                  *
                  *  The 1 ms interrupt interval is configured based on the frequency determined
                  *  by PSoC Creator at build time. If System clock frequency is changed in
                  *  runtime, the CyDelayFreq() with the appropriate parameter should be called.
                  *
                  *******************************************************************************/
                  void CySysTickInit(void)
                  {
                      uint32 i;
              
                      for (i = 0u; i<CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                      {
                          CySysTickCallbacks[i] = (void *) 0;
                      }
              
                      (void) CyIntSetSysVector(CY_INT_SYSTICK_IRQN, &CySysTickServiceCallbacks);
                      CySysTickSetClockSource(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK);
                      CySysTickSetReload(cydelay_freq_hz/1000u);
                      CySysTickClear();
                      CyIntEnable(CY_INT_SYSTICK_IRQN);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick timer and its interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnable(void)
                  {
                      CySysTickEnableInterrupt();
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickStop
                  ********************************************************************************
                  *
                  * Summary:
                  *  Stops the system timer (SysTick).
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 50  

                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStop(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE_INT;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickDisableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Disables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickDisableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE_INT));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero. This
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 51  

                  *  function do not change or reset current sysTick counter value, so it should
                  *  be cleared using CySysTickClear() API.
                  *
                  * Parameters:
                  *  value: Valid range [0x0-0x00FFFFFF]. Counter reset value.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickSetReload(uint32 value)
                  {
                      CY_SYS_SYST_RVR_REG = (value & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Counter reset value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetReload(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetValue
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets current SysTick counter value.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current SysTick counter value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetValue(void)
                  {
                      return(CY_SYS_SYST_CVR_REG & CY_SYS_SYST_CVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetClockSource
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the clock source for the SysTick counter.
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 52  

                  *
                  *  Clears SysTick count flag if it was set. If clock source is not ready this
                  *  function call will have no effect. After changing clock source to the low
                  *  frequency clock the counter and reload register values will remain unchanged
                  *  so time to the interrupt will be significantly bigger and vice versa.
                  *
                  *  The function is not available on PSoC 4000, PSoC 4100, and PSoC 42000
                  *  devices. The SysTick timer clocked by the System clock on these devices.
                  *
                  * Parameters:
                  *  clockSource: Clock source for SysTick counter
                  *         Define                     Clock Source
                  *   CY_SYS_SYST_CSR_CLK_SRC_SYSCLK     SysTick is clocked by CPU clock.
                  *   CY_SYS_SYST_CSR_CLK_SRC_LFCLK      SysTick is clocked by the low frequency
                  *                                      clock. (ILO 100 KHz for PSoC 5LP, and
                  *                                      LFCLK for PSoC 4).
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickSetClockSource(uint32 clockSource)
                  {
                      if (clockSource == CY_SYS_SYST_CSR_CLK_SRC_SYSCLK)
                      {
                          CY_SYS_SYST_CSR_REG |= (uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURCE_S
             -HIFT);
                      }
                      else
                      {
                          CY_SYS_SYST_CSR_REG &= ((uint32) ~((uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_
             -CLK_SOURCE_SHIFT)));
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCountFlag
                  ********************************************************************************
                  *
                  * Summary:
                  *  The count flag is set once SysTick counter reaches zero.
                  *   The flag cleared on read.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Returns non-zero value if flag is set, otherwise zero is returned.
                  *
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set.
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetCountFlag(void)
                  {
                      return ((CY_SYS_SYST_CSR_REG >> CY_SYS_SYST_CSR_COUNTFLAG_SHIFT) & 0x01u);
                  }
              
              
                  /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 53  

                  * Function Name: CySysTickClear
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the SysTick counter for well-defined startup.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickClear(void)
                  {
                      CY_SYS_SYST_CVR_REG = 0u;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  This function allows up to five user-defined interrupt service routine
                  *  functions to be associated with the SysTick interrupt. These are specified
                  *  through the use of pointers to the function.
                  *
                  *  To set a custom callback function without the overhead of the system provided
                  *  one, use CyIntSetSysVector(CY_INT_SYSTICK_IRQN, cyisraddress <address>),
                  *  where <address> is address of the custom defined interrupt service routine.
                  *  Note: a custom callback function overrides the system defined callback
                  *  functions.
                  *
                  * Parameters:
                  *  number: The number of the callback function addresses to be set. The valid
                  *          range is from 0 to 4.
                  *
                  *  void(*CallbackFunction(void): A pointer to the function that will be
                  *                                associated with the SysTick ISR for the
                  *                                specified number.
                  *
                  * Return:
                  *  Returns the address of the previous callback function.
                  *  The NULL is returned if the specified address in not set.
                  *
                  * Side Effects:
                  *  The registered callback functions will be executed in the interrupt.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function)
                  {
                      cySysTickCallback retVal;
              
                      retVal = CySysTickCallbacks[number];
                      CySysTickCallbacks[number] = function;
                      return (retVal);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCallback
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 54  

                  ********************************************************************************
                  *
                  * Summary:
                  *  The function get the specified callback pointer.
                  *
                  * Parameters:
                  *  number: The number of callback function address to get. The valid
                  *          range is from 0 to 4.
                  *
                  * Return:
                  *  Returns the address of the specified callback function.
                  *  The NULL is returned if the specified address in not initialized.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickGetCallback(uint32 number)
                  {
                      return ((cySysTickCallback) CySysTickCallbacks[number]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickServiceCallbacks
                  ********************************************************************************
                  *
                  * Summary:
                  *  System Tick timer interrupt routine
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  static void CySysTickServiceCallbacks(void)
                  {
                      uint32 i;
              
                      /* Verify that tick timer flag was set */
                      if (1u == CySysTickGetCountFlag())
                      {
                          for (i=0u; i < CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                          {
                              if (CySysTickCallbacks[i] != (void *) 0)
                              {
                                  (void)(CySysTickCallbacks[i])();
                              }
                          }
                      }
                  }
              #endif /* (CY_PSOC5) */
3322          
3323          
3324          /*******************************************************************************
3325          * Function Name: CyGetUniqueId
3326          ********************************************************************************
3327          *
3328          * Summary:
3329          *  Returns the 64-bit unique ID of the device. The uniqueness of the number is
3330          *  guaranteed for 10 years due to the die lot number having a cycle life of 10
3331          *  years and even after 10 years, the probability of getting two identical
3332          *  numbers is very small.
C51 COMPILER V9.51   CYLIB                                                                 04/24/2016 02:18:59 PAGE 55  

3333          *
3334          * Parameters:
3335          *  uniqueId: The pointer to a two element 32-bit unsigned integer array. Returns
3336          *  the 64-bit unique ID of the device by loading them into the integer array
3337          *  pointed to by uniqueId.
3338          *
3339          * Return:
3340          *  None
3341          *
3342          *******************************************************************************/
3343          void CyGetUniqueId(uint32* uniqueId)
3344          {
3345   1      #if(CY_PSOC4)
                  uniqueId[0u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT0  );
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT1  ) <<  8u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT2  ) << 16u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_WAFER ) << 24u);
              
                  uniqueId[1u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_X     );
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_Y     ) <<  8u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_SORT  ) << 16u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_MINOR ) << 24u);
              #else
3356   1          uniqueId[0u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_LSB   ));
3357   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_MSB   )) <<  8
             -u);
3358   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_MLOGIC_REV_ID                )) << 16
             -u);
3359   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WAFER_NUM )) << 24
             -u);
3360   1      
3361   1          uniqueId[1u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_X_LOC     ));
3362   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_Y_LOC     )) <<  8
             -u);
3363   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WRK_WK    )) << 16
             -u);
3364   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_FAB_YR    )) << 24
             -u);
3365   1      #endif  /* (CY_PSOC4) */
3366   1      }
3367          
3368          /* [] END OF FILE */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5307    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    117    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
