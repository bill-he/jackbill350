ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"UART_1.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	UART_1_initVar
  19              		.bss
  20              		.type	UART_1_initVar, %object
  21              		.size	UART_1_initVar, 1
  22              	UART_1_initVar:
  23 0000 00       		.space	1
  24              		.section	.text.UART_1_Start,"ax",%progbits
  25              		.align	2
  26              		.global	UART_1_Start
  27              		.thumb
  28              		.thumb_func
  29              		.type	UART_1_Start, %function
  30              	UART_1_Start:
  31              	.LFB0:
  32              		.file 1 ".\\Generated_Source\\PSoC5\\UART_1.c"
   1:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC5/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC5/UART_1.c **** * Version 2.50
   4:.\Generated_Source\PSoC5/UART_1.c **** *
   5:.\Generated_Source\PSoC5/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC5/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC5/UART_1.c **** *
   8:.\Generated_Source\PSoC5/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC5/UART_1.c **** *
  10:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC5/UART_1.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC5/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC5/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC5/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC5/UART_1.c **** 
  17:.\Generated_Source\PSoC5/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC5/UART_1.c **** #if (UART_1_INTERNAL_CLOCK_USED)
  19:.\Generated_Source\PSoC5/UART_1.c ****     #include "UART_1_IntClock.h"
  20:.\Generated_Source\PSoC5/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  21:.\Generated_Source\PSoC5/UART_1.c **** 
  22:.\Generated_Source\PSoC5/UART_1.c **** 
  23:.\Generated_Source\PSoC5/UART_1.c **** /***************************************
  24:.\Generated_Source\PSoC5/UART_1.c **** * Global data allocation
  25:.\Generated_Source\PSoC5/UART_1.c **** ***************************************/
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 2


  26:.\Generated_Source\PSoC5/UART_1.c **** 
  27:.\Generated_Source\PSoC5/UART_1.c **** uint8 UART_1_initVar = 0u;
  28:.\Generated_Source\PSoC5/UART_1.c **** 
  29:.\Generated_Source\PSoC5/UART_1.c **** #if (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED)
  30:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TX_BUFFER_SIZE];
  31:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC5/UART_1.c **** #endif /* (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED) */
  34:.\Generated_Source\PSoC5/UART_1.c **** 
  35:.\Generated_Source\PSoC5/UART_1.c **** #if (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED))
  36:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_errorStatus = 0u;
  37:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RX_BUFFER_SIZE];
  38:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferRead  = 0u;
  39:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  40:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  41:.\Generated_Source\PSoC5/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow   = 0u;
  42:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  43:.\Generated_Source\PSoC5/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RX_ADDRESS_MODE;
  44:.\Generated_Source\PSoC5/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  45:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
  46:.\Generated_Source\PSoC5/UART_1.c **** #endif /* (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED)) */
  47:.\Generated_Source\PSoC5/UART_1.c **** 
  48:.\Generated_Source\PSoC5/UART_1.c **** 
  49:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
  50:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Start
  51:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  52:.\Generated_Source\PSoC5/UART_1.c **** *
  53:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
  54:.\Generated_Source\PSoC5/UART_1.c **** *  This is the preferred method to begin component operation.
  55:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_Start() sets the initVar variable, calls the
  56:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_Init() function, and then calls the
  57:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_Enable() function.
  58:.\Generated_Source\PSoC5/UART_1.c **** *
  59:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
  60:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC5/UART_1.c **** *
  62:.\Generated_Source\PSoC5/UART_1.c **** * Return:
  63:.\Generated_Source\PSoC5/UART_1.c **** *  None.
  64:.\Generated_Source\PSoC5/UART_1.c **** *
  65:.\Generated_Source\PSoC5/UART_1.c **** * Global variables:
  66:.\Generated_Source\PSoC5/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  67:.\Generated_Source\PSoC5/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:.\Generated_Source\PSoC5/UART_1.c **** *  and set to one (1u) the first time UART_1_Start() is called. This
  69:.\Generated_Source\PSoC5/UART_1.c **** *  allows for component initialization without re-initialization in all
  70:.\Generated_Source\PSoC5/UART_1.c **** *  subsequent calls to the UART_1_Start() routine.
  71:.\Generated_Source\PSoC5/UART_1.c **** *
  72:.\Generated_Source\PSoC5/UART_1.c **** * Reentrant:
  73:.\Generated_Source\PSoC5/UART_1.c **** *  No.
  74:.\Generated_Source\PSoC5/UART_1.c **** *
  75:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
  76:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Start(void) 
  77:.\Generated_Source\PSoC5/UART_1.c **** {
  33              		.loc 1 77 0
  34              		.cfi_startproc
  35              		@ args = 0, pretend = 0, frame = 0
  36              		@ frame_needed = 1, uses_anonymous_args = 0
  37 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 3


  38              		.cfi_def_cfa_offset 8
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  41 0002 00AF     		add	r7, sp, #0
  42              		.cfi_def_cfa_register 7
  78:.\Generated_Source\PSoC5/UART_1.c ****     /* If not initialized then initialize all required hardware and software */
  79:.\Generated_Source\PSoC5/UART_1.c ****     if(UART_1_initVar == 0u)
  43              		.loc 1 79 0
  44 0004 054B     		ldr	r3, .L3
  45 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  46 0008 002B     		cmp	r3, #0
  47 000a 04D1     		bne	.L2
  80:.\Generated_Source\PSoC5/UART_1.c ****     {
  81:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_Init();
  48              		.loc 1 81 0
  49 000c FFF7FEFF 		bl	UART_1_Init
  82:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_initVar = 1u;
  50              		.loc 1 82 0
  51 0010 024B     		ldr	r3, .L3
  52 0012 0122     		movs	r2, #1
  53 0014 1A70     		strb	r2, [r3]
  54              	.L2:
  83:.\Generated_Source\PSoC5/UART_1.c ****     }
  84:.\Generated_Source\PSoC5/UART_1.c **** 
  85:.\Generated_Source\PSoC5/UART_1.c ****     UART_1_Enable();
  55              		.loc 1 85 0
  56 0016 FFF7FEFF 		bl	UART_1_Enable
  86:.\Generated_Source\PSoC5/UART_1.c **** }
  57              		.loc 1 86 0
  58 001a 80BD     		pop	{r7, pc}
  59              	.L4:
  60              		.align	2
  61              	.L3:
  62 001c 00000000 		.word	UART_1_initVar
  63              		.cfi_endproc
  64              	.LFE0:
  65              		.size	UART_1_Start, .-UART_1_Start
  66              		.section	.text.UART_1_Init,"ax",%progbits
  67              		.align	2
  68              		.global	UART_1_Init
  69              		.thumb
  70              		.thumb_func
  71              		.type	UART_1_Init, %function
  72              	UART_1_Init:
  73              	.LFB1:
  87:.\Generated_Source\PSoC5/UART_1.c **** 
  88:.\Generated_Source\PSoC5/UART_1.c **** 
  89:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
  90:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Init
  91:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
  92:.\Generated_Source\PSoC5/UART_1.c **** *
  93:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
  94:.\Generated_Source\PSoC5/UART_1.c **** *  Initializes or restores the component according to the customizer Configure
  95:.\Generated_Source\PSoC5/UART_1.c **** *  dialog settings. It is not necessary to call UART_1_Init() because
  96:.\Generated_Source\PSoC5/UART_1.c **** *  the UART_1_Start() API calls this function and is the preferred
  97:.\Generated_Source\PSoC5/UART_1.c **** *  method to begin component operation.
  98:.\Generated_Source\PSoC5/UART_1.c **** *
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 4


  99:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 100:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 101:.\Generated_Source\PSoC5/UART_1.c **** *
 102:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 103:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 104:.\Generated_Source\PSoC5/UART_1.c **** *
 105:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 106:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Init(void) 
 107:.\Generated_Source\PSoC5/UART_1.c **** {
  74              		.loc 1 107 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 1, uses_anonymous_args = 0
  78              		@ link register save eliminated.
  79 0000 80B4     		push	{r7}
  80              		.cfi_def_cfa_offset 4
  81              		.cfi_offset 7, -4
  82 0002 00AF     		add	r7, sp, #0
  83              		.cfi_def_cfa_register 7
 108:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 109:.\Generated_Source\PSoC5/UART_1.c **** 
 110:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 111:.\Generated_Source\PSoC5/UART_1.c ****             /* Set RX interrupt vector and priority */
 112:.\Generated_Source\PSoC5/UART_1.c ****             (void) CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 113:.\Generated_Source\PSoC5/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 114:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_errorStatus = 0u;
 115:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 116:.\Generated_Source\PSoC5/UART_1.c **** 
 117:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 118:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RX_ADDRESS_MODE);
 119:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RX_HW_ADDRESS1);
 120:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RX_HW_ADDRESS2);
 121:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 122:.\Generated_Source\PSoC5/UART_1.c **** 
 123:.\Generated_Source\PSoC5/UART_1.c ****         /* Init Count7 period */
 124:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
 125:.\Generated_Source\PSoC5/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 126:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
 127:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 128:.\Generated_Source\PSoC5/UART_1.c **** 
 129:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 130:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 131:.\Generated_Source\PSoC5/UART_1.c ****             /* Set TX interrupt vector and priority */
 132:.\Generated_Source\PSoC5/UART_1.c ****             (void) CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 133:.\Generated_Source\PSoC5/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 134:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 135:.\Generated_Source\PSoC5/UART_1.c **** 
 136:.\Generated_Source\PSoC5/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TXCLKGEN_DP)
 138:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
 139:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 140:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT) - 1u;
 141:.\Generated_Source\PSoC5/UART_1.c ****         #else
 142:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
  84              		.loc 1 142 0
  85 0004 044B     		ldr	r3, .L6
  86 0006 4722     		movs	r2, #71
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 5


  87 0008 1A70     		strb	r2, [r3]
 143:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 144:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 145:.\Generated_Source\PSoC5/UART_1.c **** 
 146:.\Generated_Source\PSoC5/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 147:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 148:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 149:.\Generated_Source\PSoC5/UART_1.c ****         #else
 150:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
  88              		.loc 1 150 0
  89 000a 044B     		ldr	r3, .L6+4
  90 000c 0122     		movs	r2, #1
  91 000e 1A70     		strb	r2, [r3]
 151:.\Generated_Source\PSoC5/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 152:.\Generated_Source\PSoC5/UART_1.c **** 
 153:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 154:.\Generated_Source\PSoC5/UART_1.c **** 
 155:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_WriteControlRegister( \
 157:.\Generated_Source\PSoC5/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 158:.\Generated_Source\PSoC5/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 159:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 160:.\Generated_Source\PSoC5/UART_1.c **** }
  92              		.loc 1 160 0
  93 0010 BD46     		mov	sp, r7
  94              		.cfi_def_cfa_register 13
  95              		@ sp needed
  96 0012 5DF8047B 		ldr	r7, [sp], #4
  97              		.cfi_restore 7
  98              		.cfi_def_cfa_offset 0
  99 0016 7047     		bx	lr
 100              	.L7:
 101              		.align	2
 102              	.L6:
 103 0018 83640040 		.word	1073767555
 104 001c 82640040 		.word	1073767554
 105              		.cfi_endproc
 106              	.LFE1:
 107              		.size	UART_1_Init, .-UART_1_Init
 108              		.section	.text.UART_1_Enable,"ax",%progbits
 109              		.align	2
 110              		.global	UART_1_Enable
 111              		.thumb
 112              		.thumb_func
 113              		.type	UART_1_Enable, %function
 114              	UART_1_Enable:
 115              	.LFB2:
 161:.\Generated_Source\PSoC5/UART_1.c **** 
 162:.\Generated_Source\PSoC5/UART_1.c **** 
 163:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 164:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Enable
 165:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 166:.\Generated_Source\PSoC5/UART_1.c **** *
 167:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 168:.\Generated_Source\PSoC5/UART_1.c **** *  Activates the hardware and begins component operation. It is not necessary
 169:.\Generated_Source\PSoC5/UART_1.c **** *  to call UART_1_Enable() because the UART_1_Start() API
 170:.\Generated_Source\PSoC5/UART_1.c **** *  calls this function, which is the preferred method to begin component
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 6


 171:.\Generated_Source\PSoC5/UART_1.c **** *  operation.
 172:.\Generated_Source\PSoC5/UART_1.c **** 
 173:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 174:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 175:.\Generated_Source\PSoC5/UART_1.c **** *
 176:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 177:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 178:.\Generated_Source\PSoC5/UART_1.c **** *
 179:.\Generated_Source\PSoC5/UART_1.c **** * Global Variables:
 180:.\Generated_Source\PSoC5/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 181:.\Generated_Source\PSoC5/UART_1.c **** *
 182:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 183:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Enable(void) 
 184:.\Generated_Source\PSoC5/UART_1.c **** {
 116              		.loc 1 184 0
 117              		.cfi_startproc
 118              		@ args = 0, pretend = 0, frame = 8
 119              		@ frame_needed = 1, uses_anonymous_args = 0
 120 0000 80B5     		push	{r7, lr}
 121              		.cfi_def_cfa_offset 8
 122              		.cfi_offset 7, -8
 123              		.cfi_offset 14, -4
 124 0002 82B0     		sub	sp, sp, #8
 125              		.cfi_def_cfa_offset 16
 126 0004 00AF     		add	r7, sp, #0
 127              		.cfi_def_cfa_register 7
 185:.\Generated_Source\PSoC5/UART_1.c ****     uint8 enableInterrupts;
 186:.\Generated_Source\PSoC5/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 128              		.loc 1 186 0
 129 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 130 000a 0346     		mov	r3, r0
 131 000c FB71     		strb	r3, [r7, #7]
 187:.\Generated_Source\PSoC5/UART_1.c **** 
 188:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 189:.\Generated_Source\PSoC5/UART_1.c ****         /* RX Counter (Count7) Enable */
 190:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 191:.\Generated_Source\PSoC5/UART_1.c **** 
 192:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable the RX Interrupt */
 193:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 194:.\Generated_Source\PSoC5/UART_1.c **** 
 195:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 196:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableRxInt();
 197:.\Generated_Source\PSoC5/UART_1.c **** 
 198:.\Generated_Source\PSoC5/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 199:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 200:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
 201:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 202:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 203:.\Generated_Source\PSoC5/UART_1.c **** 
 204:.\Generated_Source\PSoC5/UART_1.c ****     #if(UART_1_TX_ENABLED)
 205:.\Generated_Source\PSoC5/UART_1.c ****         /* TX Counter (DP/Count7) Enable */
 206:.\Generated_Source\PSoC5/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 207:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 132              		.loc 1 207 0
 133 000e 0B4A     		ldr	r2, .L9
 134 0010 0A4B     		ldr	r3, .L9
 135 0012 1B78     		ldrb	r3, [r3]
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 7


 136 0014 DBB2     		uxtb	r3, r3
 137 0016 43F02003 		orr	r3, r3, #32
 138 001a DBB2     		uxtb	r3, r3
 139 001c 1370     		strb	r3, [r2]
 208:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 209:.\Generated_Source\PSoC5/UART_1.c **** 
 210:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable the TX Interrupt */
 211:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 140              		.loc 1 211 0
 141 001e 084A     		ldr	r2, .L9+4
 142 0020 074B     		ldr	r3, .L9+4
 143 0022 1B78     		ldrb	r3, [r3]
 144 0024 DBB2     		uxtb	r3, r3
 145 0026 43F01003 		orr	r3, r3, #16
 146 002a DBB2     		uxtb	r3, r3
 147 002c 1370     		strb	r3, [r2]
 212:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 213:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
 215:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 216:.\Generated_Source\PSoC5/UART_1.c ****      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 217:.\Generated_Source\PSoC5/UART_1.c **** 
 218:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 219:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_IntClock_Start();  /* Enable the clock */
 220:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 221:.\Generated_Source\PSoC5/UART_1.c **** 
 222:.\Generated_Source\PSoC5/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 148              		.loc 1 222 0
 149 002e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 150 0030 1846     		mov	r0, r3
 151 0032 FFF7FEFF 		bl	CyExitCriticalSection
 223:.\Generated_Source\PSoC5/UART_1.c **** }
 152              		.loc 1 223 0
 153 0036 0837     		adds	r7, r7, #8
 154              		.cfi_def_cfa_offset 8
 155 0038 BD46     		mov	sp, r7
 156              		.cfi_def_cfa_register 13
 157              		@ sp needed
 158 003a 80BD     		pop	{r7, pc}
 159              	.L10:
 160              		.align	2
 161              	.L9:
 162 003c 93640040 		.word	1073767571
 163 0040 92640040 		.word	1073767570
 164              		.cfi_endproc
 165              	.LFE2:
 166              		.size	UART_1_Enable, .-UART_1_Enable
 167              		.section	.text.UART_1_Stop,"ax",%progbits
 168              		.align	2
 169              		.global	UART_1_Stop
 170              		.thumb
 171              		.thumb_func
 172              		.type	UART_1_Stop, %function
 173              	UART_1_Stop:
 174              	.LFB3:
 224:.\Generated_Source\PSoC5/UART_1.c **** 
 225:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 8


 226:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 227:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_Stop
 228:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 229:.\Generated_Source\PSoC5/UART_1.c **** *
 230:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 231:.\Generated_Source\PSoC5/UART_1.c **** *  Disables the UART operation.
 232:.\Generated_Source\PSoC5/UART_1.c **** *
 233:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 234:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 235:.\Generated_Source\PSoC5/UART_1.c **** *
 236:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 237:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 238:.\Generated_Source\PSoC5/UART_1.c **** *
 239:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 240:.\Generated_Source\PSoC5/UART_1.c **** void UART_1_Stop(void) 
 241:.\Generated_Source\PSoC5/UART_1.c **** {
 175              		.loc 1 241 0
 176              		.cfi_startproc
 177              		@ args = 0, pretend = 0, frame = 8
 178              		@ frame_needed = 1, uses_anonymous_args = 0
 179 0000 80B5     		push	{r7, lr}
 180              		.cfi_def_cfa_offset 8
 181              		.cfi_offset 7, -8
 182              		.cfi_offset 14, -4
 183 0002 82B0     		sub	sp, sp, #8
 184              		.cfi_def_cfa_offset 16
 185 0004 00AF     		add	r7, sp, #0
 186              		.cfi_def_cfa_register 7
 242:.\Generated_Source\PSoC5/UART_1.c ****     uint8 enableInterrupts;
 243:.\Generated_Source\PSoC5/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 187              		.loc 1 243 0
 188 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 189 000a 0346     		mov	r3, r0
 190 000c FB71     		strb	r3, [r7, #7]
 244:.\Generated_Source\PSoC5/UART_1.c **** 
 245:.\Generated_Source\PSoC5/UART_1.c ****     /* Write Bit Counter Disable */
 246:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 247:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 248:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 249:.\Generated_Source\PSoC5/UART_1.c **** 
 250:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_ENABLED)
 251:.\Generated_Source\PSoC5/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 252:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 191              		.loc 1 252 0
 192 000e 0B4A     		ldr	r2, .L12
 193 0010 0A4B     		ldr	r3, .L12
 194 0012 1B78     		ldrb	r3, [r3]
 195 0014 DBB2     		uxtb	r3, r3
 196 0016 23F02003 		bic	r3, r3, #32
 197 001a DBB2     		uxtb	r3, r3
 198 001c 1370     		strb	r3, [r2]
 253:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (!UART_1_TXCLKGEN_DP) */
 254:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 255:.\Generated_Source\PSoC5/UART_1.c **** 
 256:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 257:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_IntClock_Stop();   /* Disable the clock */
 258:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 9


 259:.\Generated_Source\PSoC5/UART_1.c **** 
 260:.\Generated_Source\PSoC5/UART_1.c ****     /* Disable internal interrupt component */
 261:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 262:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8) ~UART_1_INT_ENABLE;
 263:.\Generated_Source\PSoC5/UART_1.c **** 
 264:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 265:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableRxInt();
 266:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 267:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 268:.\Generated_Source\PSoC5/UART_1.c **** 
 269:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_ENABLED)
 270:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8) ~UART_1_INT_ENABLE;
 199              		.loc 1 270 0
 200 001e 084A     		ldr	r2, .L12+4
 201 0020 074B     		ldr	r3, .L12+4
 202 0022 1B78     		ldrb	r3, [r3]
 203 0024 DBB2     		uxtb	r3, r3
 204 0026 23F01003 		bic	r3, r3, #16
 205 002a DBB2     		uxtb	r3, r3
 206 002c 1370     		strb	r3, [r2]
 271:.\Generated_Source\PSoC5/UART_1.c **** 
 272:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 273:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
 274:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 275:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 276:.\Generated_Source\PSoC5/UART_1.c **** 
 277:.\Generated_Source\PSoC5/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 207              		.loc 1 277 0
 208 002e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 209 0030 1846     		mov	r0, r3
 210 0032 FFF7FEFF 		bl	CyExitCriticalSection
 278:.\Generated_Source\PSoC5/UART_1.c **** }
 211              		.loc 1 278 0
 212 0036 0837     		adds	r7, r7, #8
 213              		.cfi_def_cfa_offset 8
 214 0038 BD46     		mov	sp, r7
 215              		.cfi_def_cfa_register 13
 216              		@ sp needed
 217 003a 80BD     		pop	{r7, pc}
 218              	.L13:
 219              		.align	2
 220              	.L12:
 221 003c 93640040 		.word	1073767571
 222 0040 92640040 		.word	1073767570
 223              		.cfi_endproc
 224              	.LFE3:
 225              		.size	UART_1_Stop, .-UART_1_Stop
 226              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 227              		.align	2
 228              		.global	UART_1_ReadControlRegister
 229              		.thumb
 230              		.thumb_func
 231              		.type	UART_1_ReadControlRegister, %function
 232              	UART_1_ReadControlRegister:
 233              	.LFB4:
 279:.\Generated_Source\PSoC5/UART_1.c **** 
 280:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 10


 281:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
 282:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 283:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 284:.\Generated_Source\PSoC5/UART_1.c **** *
 285:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 286:.\Generated_Source\PSoC5/UART_1.c **** *  Returns the current value of the control register.
 287:.\Generated_Source\PSoC5/UART_1.c **** *
 288:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 289:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 290:.\Generated_Source\PSoC5/UART_1.c **** *
 291:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 292:.\Generated_Source\PSoC5/UART_1.c **** *  Contents of the control register.
 293:.\Generated_Source\PSoC5/UART_1.c **** *
 294:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 295:.\Generated_Source\PSoC5/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 296:.\Generated_Source\PSoC5/UART_1.c **** {
 234              		.loc 1 296 0
 235              		.cfi_startproc
 236              		@ args = 0, pretend = 0, frame = 0
 237              		@ frame_needed = 1, uses_anonymous_args = 0
 238              		@ link register save eliminated.
 239 0000 80B4     		push	{r7}
 240              		.cfi_def_cfa_offset 4
 241              		.cfi_offset 7, -4
 242 0002 00AF     		add	r7, sp, #0
 243              		.cfi_def_cfa_register 7
 297:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 298:.\Generated_Source\PSoC5/UART_1.c ****         return(0u);
 244              		.loc 1 298 0
 245 0004 0023     		movs	r3, #0
 299:.\Generated_Source\PSoC5/UART_1.c ****     #else
 300:.\Generated_Source\PSoC5/UART_1.c ****         return(UART_1_CONTROL_REG);
 301:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 302:.\Generated_Source\PSoC5/UART_1.c **** }
 246              		.loc 1 302 0
 247 0006 1846     		mov	r0, r3
 248 0008 BD46     		mov	sp, r7
 249              		.cfi_def_cfa_register 13
 250              		@ sp needed
 251 000a 5DF8047B 		ldr	r7, [sp], #4
 252              		.cfi_restore 7
 253              		.cfi_def_cfa_offset 0
 254 000e 7047     		bx	lr
 255              		.cfi_endproc
 256              	.LFE4:
 257              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 258              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 259              		.align	2
 260              		.global	UART_1_WriteControlRegister
 261              		.thumb
 262              		.thumb_func
 263              		.type	UART_1_WriteControlRegister, %function
 264              	UART_1_WriteControlRegister:
 265              	.LFB5:
 303:.\Generated_Source\PSoC5/UART_1.c **** 
 304:.\Generated_Source\PSoC5/UART_1.c **** 
 305:.\Generated_Source\PSoC5/UART_1.c **** /*******************************************************************************
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 11


 306:.\Generated_Source\PSoC5/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 307:.\Generated_Source\PSoC5/UART_1.c **** ********************************************************************************
 308:.\Generated_Source\PSoC5/UART_1.c **** *
 309:.\Generated_Source\PSoC5/UART_1.c **** * Summary:
 310:.\Generated_Source\PSoC5/UART_1.c **** *  Writes an 8-bit value into the control register
 311:.\Generated_Source\PSoC5/UART_1.c **** *
 312:.\Generated_Source\PSoC5/UART_1.c **** * Parameters:
 313:.\Generated_Source\PSoC5/UART_1.c **** *  control:  control register value
 314:.\Generated_Source\PSoC5/UART_1.c **** *
 315:.\Generated_Source\PSoC5/UART_1.c **** * Return:
 316:.\Generated_Source\PSoC5/UART_1.c **** *  None.
 317:.\Generated_Source\PSoC5/UART_1.c **** *
 318:.\Generated_Source\PSoC5/UART_1.c **** *******************************************************************************/
 319:.\Generated_Source\PSoC5/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 320:.\Generated_Source\PSoC5/UART_1.c **** {
 266              		.loc 1 320 0
 267              		.cfi_startproc
 268              		@ args = 0, pretend = 0, frame = 8
 269              		@ frame_needed = 1, uses_anonymous_args = 0
 270              		@ link register save eliminated.
 271 0000 80B4     		push	{r7}
 272              		.cfi_def_cfa_offset 4
 273              		.cfi_offset 7, -4
 274 0002 83B0     		sub	sp, sp, #12
 275              		.cfi_def_cfa_offset 16
 276 0004 00AF     		add	r7, sp, #0
 277              		.cfi_def_cfa_register 7
 278 0006 0346     		mov	r3, r0
 279 0008 FB71     		strb	r3, [r7, #7]
 321:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 322:.\Generated_Source\PSoC5/UART_1.c ****         if(0u != control)
 323:.\Generated_Source\PSoC5/UART_1.c ****         {
 324:.\Generated_Source\PSoC5/UART_1.c ****             /* Suppress compiler warning */
 325:.\Generated_Source\PSoC5/UART_1.c ****         }
 326:.\Generated_Source\PSoC5/UART_1.c ****     #else
 327:.\Generated_Source\PSoC5/UART_1.c ****        UART_1_CONTROL_REG = control;
 328:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 329:.\Generated_Source\PSoC5/UART_1.c **** }
 280              		.loc 1 329 0
 281 000a 0C37     		adds	r7, r7, #12
 282              		.cfi_def_cfa_offset 4
 283 000c BD46     		mov	sp, r7
 284              		.cfi_def_cfa_register 13
 285              		@ sp needed
 286 000e 5DF8047B 		ldr	r7, [sp], #4
 287              		.cfi_restore 7
 288              		.cfi_def_cfa_offset 0
 289 0012 7047     		bx	lr
 290              		.cfi_endproc
 291              	.LFE5:
 292              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 293              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 294              		.align	2
 295              		.global	UART_1_SetTxInterruptMode
 296              		.thumb
 297              		.thumb_func
 298              		.type	UART_1_SetTxInterruptMode, %function
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 12


 299              	UART_1_SetTxInterruptMode:
 300              	.LFB6:
 330:.\Generated_Source\PSoC5/UART_1.c **** 
 331:.\Generated_Source\PSoC5/UART_1.c **** 
 332:.\Generated_Source\PSoC5/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 333:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 334:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 335:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 336:.\Generated_Source\PSoC5/UART_1.c ****     *
 337:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 338:.\Generated_Source\PSoC5/UART_1.c ****     *  Configures the RX interrupt sources enabled.
 339:.\Generated_Source\PSoC5/UART_1.c ****     *
 340:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 341:.\Generated_Source\PSoC5/UART_1.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:.\Generated_Source\PSoC5/UART_1.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:.\Generated_Source\PSoC5/UART_1.c ****     *  combination of status register bit-masks shown below:
 344:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_BREAK            Interrupt on break.
 348:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_OVERRUN          Interrupt on overrun error.
 349:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_RX_STS_MRKSPC           Interrupt on address detect.
 351:.\Generated_Source\PSoC5/UART_1.c ****     *
 352:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 353:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 354:.\Generated_Source\PSoC5/UART_1.c ****     *
 355:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 356:.\Generated_Source\PSoC5/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:.\Generated_Source\PSoC5/UART_1.c ****     *
 358:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 359:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 360:.\Generated_Source\PSoC5/UART_1.c ****     {
 361:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 362:.\Generated_Source\PSoC5/UART_1.c ****     }
 363:.\Generated_Source\PSoC5/UART_1.c **** 
 364:.\Generated_Source\PSoC5/UART_1.c **** 
 365:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 366:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadRxData
 367:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 368:.\Generated_Source\PSoC5/UART_1.c ****     *
 369:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 370:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the next byte of received data. This function returns data without
 371:.\Generated_Source\PSoC5/UART_1.c ****     *  checking the status. You must check the status separately.
 372:.\Generated_Source\PSoC5/UART_1.c ****     *
 373:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 374:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 375:.\Generated_Source\PSoC5/UART_1.c ****     *
 376:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 377:.\Generated_Source\PSoC5/UART_1.c ****     *  Received data from RX register
 378:.\Generated_Source\PSoC5/UART_1.c ****     *
 379:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 380:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 381:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 382:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify new data.
 383:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 384:.\Generated_Source\PSoC5/UART_1.c ****     *     incremented after each byte has been read from buffer.
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 13


 385:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 386:.\Generated_Source\PSoC5/UART_1.c ****     *     in RX ISR.
 387:.\Generated_Source\PSoC5/UART_1.c ****     *
 388:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 389:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 390:.\Generated_Source\PSoC5/UART_1.c ****     *
 391:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 392:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 393:.\Generated_Source\PSoC5/UART_1.c ****     {
 394:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxData;
 395:.\Generated_Source\PSoC5/UART_1.c **** 
 396:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 397:.\Generated_Source\PSoC5/UART_1.c **** 
 398:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferRead;
 399:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferWrite;
 400:.\Generated_Source\PSoC5/UART_1.c **** 
 401:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 402:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 403:.\Generated_Source\PSoC5/UART_1.c **** 
 404:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 405:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 406:.\Generated_Source\PSoC5/UART_1.c **** 
 407:.\Generated_Source\PSoC5/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408:.\Generated_Source\PSoC5/UART_1.c ****         {
 409:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 410:.\Generated_Source\PSoC5/UART_1.c ****             locRxBufferRead++;
 411:.\Generated_Source\PSoC5/UART_1.c **** 
 412:.\Generated_Source\PSoC5/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 413:.\Generated_Source\PSoC5/UART_1.c ****             {
 414:.\Generated_Source\PSoC5/UART_1.c ****                 locRxBufferRead = 0u;
 415:.\Generated_Source\PSoC5/UART_1.c ****             }
 416:.\Generated_Source\PSoC5/UART_1.c ****             /* Update the real pointer */
 417:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 418:.\Generated_Source\PSoC5/UART_1.c **** 
 419:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 420:.\Generated_Source\PSoC5/UART_1.c ****             {
 421:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 422:.\Generated_Source\PSoC5/UART_1.c ****                 #if ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u))
 423:.\Generated_Source\PSoC5/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:.\Generated_Source\PSoC5/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 425:.\Generated_Source\PSoC5/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 426:.\Generated_Source\PSoC5/UART_1.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:.\Generated_Source\PSoC5/UART_1.c ****                             *  configuration set, otherwise
 428:.\Generated_Source\PSoC5/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 429:.\Generated_Source\PSoC5/UART_1.c ****                             */
 430:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 431:.\Generated_Source\PSoC5/UART_1.c ****                         }
 432:.\Generated_Source\PSoC5/UART_1.c ****                     #else
 433:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 434:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 435:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u)) */
 436:.\Generated_Source\PSoC5/UART_1.c ****             }
 437:.\Generated_Source\PSoC5/UART_1.c ****         }
 438:.\Generated_Source\PSoC5/UART_1.c ****         else
 439:.\Generated_Source\PSoC5/UART_1.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 441:.\Generated_Source\PSoC5/UART_1.c ****         }
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 14


 442:.\Generated_Source\PSoC5/UART_1.c **** 
 443:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 444:.\Generated_Source\PSoC5/UART_1.c **** 
 445:.\Generated_Source\PSoC5/UART_1.c ****     #else
 446:.\Generated_Source\PSoC5/UART_1.c **** 
 447:.\Generated_Source\PSoC5/UART_1.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:.\Generated_Source\PSoC5/UART_1.c ****         rxData = UART_1_RXDATA_REG;
 449:.\Generated_Source\PSoC5/UART_1.c **** 
 450:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 451:.\Generated_Source\PSoC5/UART_1.c **** 
 452:.\Generated_Source\PSoC5/UART_1.c ****         return(rxData);
 453:.\Generated_Source\PSoC5/UART_1.c ****     }
 454:.\Generated_Source\PSoC5/UART_1.c **** 
 455:.\Generated_Source\PSoC5/UART_1.c **** 
 456:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 457:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 458:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 459:.\Generated_Source\PSoC5/UART_1.c ****     *
 460:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 461:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the current state of the receiver status register and the software
 462:.\Generated_Source\PSoC5/UART_1.c ****     *  buffer overflow status.
 463:.\Generated_Source\PSoC5/UART_1.c ****     *
 464:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 465:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 466:.\Generated_Source\PSoC5/UART_1.c ****     *
 467:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 468:.\Generated_Source\PSoC5/UART_1.c ****     *  Current state of the status register.
 469:.\Generated_Source\PSoC5/UART_1.c ****     *
 470:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effect:
 471:.\Generated_Source\PSoC5/UART_1.c ****     *  All status register bits are clear-on-read except
 472:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY.
 473:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:.\Generated_Source\PSoC5/UART_1.c ****     *  register read.
 475:.\Generated_Source\PSoC5/UART_1.c ****     *
 476:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 477:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 478:.\Generated_Source\PSoC5/UART_1.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 480:.\Generated_Source\PSoC5/UART_1.c ****     *   and cleared to zero by this API as an
 481:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:.\Generated_Source\PSoC5/UART_1.c ****     *   bits.
 483:.\Generated_Source\PSoC5/UART_1.c ****     *
 484:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 485:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 486:.\Generated_Source\PSoC5/UART_1.c ****     {
 487:.\Generated_Source\PSoC5/UART_1.c ****         uint8 status;
 488:.\Generated_Source\PSoC5/UART_1.c **** 
 489:.\Generated_Source\PSoC5/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 490:.\Generated_Source\PSoC5/UART_1.c **** 
 491:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 492:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_rxBufferOverflow != 0u)
 493:.\Generated_Source\PSoC5/UART_1.c ****         {
 494:.\Generated_Source\PSoC5/UART_1.c ****             status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 495:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 496:.\Generated_Source\PSoC5/UART_1.c ****         }
 497:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 498:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 15


 499:.\Generated_Source\PSoC5/UART_1.c ****         return(status);
 500:.\Generated_Source\PSoC5/UART_1.c ****     }
 501:.\Generated_Source\PSoC5/UART_1.c **** 
 502:.\Generated_Source\PSoC5/UART_1.c **** 
 503:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 504:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetChar
 505:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 506:.\Generated_Source\PSoC5/UART_1.c ****     *
 507:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 508:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the last received byte of data. UART_1_GetChar() is
 509:.\Generated_Source\PSoC5/UART_1.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:.\Generated_Source\PSoC5/UART_1.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:.\Generated_Source\PSoC5/UART_1.c ****     *
 512:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 513:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 514:.\Generated_Source\PSoC5/UART_1.c ****     *
 515:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 516:.\Generated_Source\PSoC5/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:.\Generated_Source\PSoC5/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 518:.\Generated_Source\PSoC5/UART_1.c ****     *
 519:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 520:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 521:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 522:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify new data.
 523:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 524:.\Generated_Source\PSoC5/UART_1.c ****     *     incremented after each byte has been read from buffer.
 525:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 526:.\Generated_Source\PSoC5/UART_1.c ****     *     in RX ISR.
 527:.\Generated_Source\PSoC5/UART_1.c ****     *
 528:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 529:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 530:.\Generated_Source\PSoC5/UART_1.c ****     *
 531:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 532:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetChar(void) 
 533:.\Generated_Source\PSoC5/UART_1.c ****     {
 534:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxData = 0u;
 535:.\Generated_Source\PSoC5/UART_1.c ****         uint8 rxStatus;
 536:.\Generated_Source\PSoC5/UART_1.c **** 
 537:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 538:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferRead;
 539:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locRxBufferWrite;
 540:.\Generated_Source\PSoC5/UART_1.c **** 
 541:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 542:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 543:.\Generated_Source\PSoC5/UART_1.c **** 
 544:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 545:.\Generated_Source\PSoC5/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 546:.\Generated_Source\PSoC5/UART_1.c **** 
 547:.\Generated_Source\PSoC5/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548:.\Generated_Source\PSoC5/UART_1.c ****         {
 549:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 550:.\Generated_Source\PSoC5/UART_1.c ****             locRxBufferRead++;
 551:.\Generated_Source\PSoC5/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 552:.\Generated_Source\PSoC5/UART_1.c ****             {
 553:.\Generated_Source\PSoC5/UART_1.c ****                 locRxBufferRead = 0u;
 554:.\Generated_Source\PSoC5/UART_1.c ****             }
 555:.\Generated_Source\PSoC5/UART_1.c ****             /* Update the real pointer */
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 16


 556:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 557:.\Generated_Source\PSoC5/UART_1.c **** 
 558:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 559:.\Generated_Source\PSoC5/UART_1.c ****             {
 560:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 561:.\Generated_Source\PSoC5/UART_1.c ****                 #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 562:.\Generated_Source\PSoC5/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:.\Generated_Source\PSoC5/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 564:.\Generated_Source\PSoC5/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 565:.\Generated_Source\PSoC5/UART_1.c ****                         {   /* In Half duplex mode return RX mask only if
 566:.\Generated_Source\PSoC5/UART_1.c ****                             *  RX configuration set, otherwise
 567:.\Generated_Source\PSoC5/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:.\Generated_Source\PSoC5/UART_1.c ****                             */
 569:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 570:.\Generated_Source\PSoC5/UART_1.c ****                         }
 571:.\Generated_Source\PSoC5/UART_1.c ****                     #else
 572:.\Generated_Source\PSoC5/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 573:.\Generated_Source\PSoC5/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 574:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:.\Generated_Source\PSoC5/UART_1.c ****             }
 576:.\Generated_Source\PSoC5/UART_1.c **** 
 577:.\Generated_Source\PSoC5/UART_1.c ****         }
 578:.\Generated_Source\PSoC5/UART_1.c ****         else
 579:.\Generated_Source\PSoC5/UART_1.c ****         {   rxStatus = UART_1_RXSTATUS_REG;
 580:.\Generated_Source\PSoC5/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 581:.\Generated_Source\PSoC5/UART_1.c ****             {   /* Read received data from FIFO */
 582:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 583:.\Generated_Source\PSoC5/UART_1.c ****                 /*Check status on error*/
 584:.\Generated_Source\PSoC5/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 585:.\Generated_Source\PSoC5/UART_1.c ****                                 UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 586:.\Generated_Source\PSoC5/UART_1.c ****                 {
 587:.\Generated_Source\PSoC5/UART_1.c ****                     rxData = 0u;
 588:.\Generated_Source\PSoC5/UART_1.c ****                 }
 589:.\Generated_Source\PSoC5/UART_1.c ****             }
 590:.\Generated_Source\PSoC5/UART_1.c ****         }
 591:.\Generated_Source\PSoC5/UART_1.c **** 
 592:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 593:.\Generated_Source\PSoC5/UART_1.c **** 
 594:.\Generated_Source\PSoC5/UART_1.c ****     #else
 595:.\Generated_Source\PSoC5/UART_1.c **** 
 596:.\Generated_Source\PSoC5/UART_1.c ****         rxStatus =UART_1_RXSTATUS_REG;
 597:.\Generated_Source\PSoC5/UART_1.c ****         if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 598:.\Generated_Source\PSoC5/UART_1.c ****         {
 599:.\Generated_Source\PSoC5/UART_1.c ****             /* Read received data from FIFO */
 600:.\Generated_Source\PSoC5/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 601:.\Generated_Source\PSoC5/UART_1.c **** 
 602:.\Generated_Source\PSoC5/UART_1.c ****             /*Check status on error*/
 603:.\Generated_Source\PSoC5/UART_1.c ****             if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 604:.\Generated_Source\PSoC5/UART_1.c ****                             UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 605:.\Generated_Source\PSoC5/UART_1.c ****             {
 606:.\Generated_Source\PSoC5/UART_1.c ****                 rxData = 0u;
 607:.\Generated_Source\PSoC5/UART_1.c ****             }
 608:.\Generated_Source\PSoC5/UART_1.c ****         }
 609:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 610:.\Generated_Source\PSoC5/UART_1.c **** 
 611:.\Generated_Source\PSoC5/UART_1.c ****         return(rxData);
 612:.\Generated_Source\PSoC5/UART_1.c ****     }
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 17


 613:.\Generated_Source\PSoC5/UART_1.c **** 
 614:.\Generated_Source\PSoC5/UART_1.c **** 
 615:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 616:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetByte
 617:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 618:.\Generated_Source\PSoC5/UART_1.c ****     *
 619:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 620:.\Generated_Source\PSoC5/UART_1.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:.\Generated_Source\PSoC5/UART_1.c ****     *  condition.
 622:.\Generated_Source\PSoC5/UART_1.c ****     *
 623:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 624:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 625:.\Generated_Source\PSoC5/UART_1.c ****     *
 626:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 627:.\Generated_Source\PSoC5/UART_1.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:.\Generated_Source\PSoC5/UART_1.c ****     *  an error has occurred.
 629:.\Generated_Source\PSoC5/UART_1.c ****     *
 630:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 631:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 632:.\Generated_Source\PSoC5/UART_1.c ****     *
 633:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 634:.\Generated_Source\PSoC5/UART_1.c ****     uint16 UART_1_GetByte(void) 
 635:.\Generated_Source\PSoC5/UART_1.c ****     {
 636:.\Generated_Source\PSoC5/UART_1.c ****         
 637:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 638:.\Generated_Source\PSoC5/UART_1.c ****         uint16 locErrorStatus;
 639:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 640:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 641:.\Generated_Source\PSoC5/UART_1.c ****         locErrorStatus = (uint16)UART_1_errorStatus;
 642:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_errorStatus = 0u;
 643:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 644:.\Generated_Source\PSoC5/UART_1.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_1_ReadRxData() );
 645:.\Generated_Source\PSoC5/UART_1.c ****     #else
 646:.\Generated_Source\PSoC5/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 647:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 648:.\Generated_Source\PSoC5/UART_1.c ****         
 649:.\Generated_Source\PSoC5/UART_1.c ****     }
 650:.\Generated_Source\PSoC5/UART_1.c **** 
 651:.\Generated_Source\PSoC5/UART_1.c **** 
 652:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 653:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 654:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 655:.\Generated_Source\PSoC5/UART_1.c ****     *
 656:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 657:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:.\Generated_Source\PSoC5/UART_1.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:.\Generated_Source\PSoC5/UART_1.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:.\Generated_Source\PSoC5/UART_1.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:.\Generated_Source\PSoC5/UART_1.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:.\Generated_Source\PSoC5/UART_1.c ****     *    account.
 663:.\Generated_Source\PSoC5/UART_1.c ****     *
 664:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 665:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 666:.\Generated_Source\PSoC5/UART_1.c ****     *
 667:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 668:.\Generated_Source\PSoC5/UART_1.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:.\Generated_Source\PSoC5/UART_1.c ****     *    Return value type depends on RX Buffer Size parameter.
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 18


 670:.\Generated_Source\PSoC5/UART_1.c ****     *
 671:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 672:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 673:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 674:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 675:.\Generated_Source\PSoC5/UART_1.c ****     *
 676:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 677:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 678:.\Generated_Source\PSoC5/UART_1.c ****     *
 679:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 680:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:.\Generated_Source\PSoC5/UART_1.c ****     *
 682:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 683:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 684:.\Generated_Source\PSoC5/UART_1.c ****                                                             
 685:.\Generated_Source\PSoC5/UART_1.c ****     {
 686:.\Generated_Source\PSoC5/UART_1.c ****         uint8 size;
 687:.\Generated_Source\PSoC5/UART_1.c **** 
 688:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 689:.\Generated_Source\PSoC5/UART_1.c **** 
 690:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt */
 691:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 692:.\Generated_Source\PSoC5/UART_1.c **** 
 693:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 694:.\Generated_Source\PSoC5/UART_1.c ****         {
 695:.\Generated_Source\PSoC5/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 696:.\Generated_Source\PSoC5/UART_1.c ****             {
 697:.\Generated_Source\PSoC5/UART_1.c ****                 size = UART_1_RX_BUFFER_SIZE;
 698:.\Generated_Source\PSoC5/UART_1.c ****             }
 699:.\Generated_Source\PSoC5/UART_1.c ****             else
 700:.\Generated_Source\PSoC5/UART_1.c ****             {
 701:.\Generated_Source\PSoC5/UART_1.c ****                 size = 0u;
 702:.\Generated_Source\PSoC5/UART_1.c ****             }
 703:.\Generated_Source\PSoC5/UART_1.c ****         }
 704:.\Generated_Source\PSoC5/UART_1.c ****         else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 705:.\Generated_Source\PSoC5/UART_1.c ****         {
 706:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 707:.\Generated_Source\PSoC5/UART_1.c ****         }
 708:.\Generated_Source\PSoC5/UART_1.c ****         else
 709:.\Generated_Source\PSoC5/UART_1.c ****         {
 710:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_RX_BUFFER_SIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 711:.\Generated_Source\PSoC5/UART_1.c ****         }
 712:.\Generated_Source\PSoC5/UART_1.c **** 
 713:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 714:.\Generated_Source\PSoC5/UART_1.c **** 
 715:.\Generated_Source\PSoC5/UART_1.c ****     #else
 716:.\Generated_Source\PSoC5/UART_1.c **** 
 717:.\Generated_Source\PSoC5/UART_1.c ****         /* We can only know if there is data in the fifo. */
 718:.\Generated_Source\PSoC5/UART_1.c ****         size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 719:.\Generated_Source\PSoC5/UART_1.c **** 
 720:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 721:.\Generated_Source\PSoC5/UART_1.c **** 
 722:.\Generated_Source\PSoC5/UART_1.c ****         return(size);
 723:.\Generated_Source\PSoC5/UART_1.c ****     }
 724:.\Generated_Source\PSoC5/UART_1.c **** 
 725:.\Generated_Source\PSoC5/UART_1.c **** 
 726:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 19


 727:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 728:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 729:.\Generated_Source\PSoC5/UART_1.c ****     *
 730:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 731:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:.\Generated_Source\PSoC5/UART_1.c ****     *
 733:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 734:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 735:.\Generated_Source\PSoC5/UART_1.c ****     *
 736:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 737:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 738:.\Generated_Source\PSoC5/UART_1.c ****     *
 739:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 740:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 741:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 742:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 743:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 744:.\Generated_Source\PSoC5/UART_1.c ****     *
 745:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 746:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 747:.\Generated_Source\PSoC5/UART_1.c ****     *
 748:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 749:.\Generated_Source\PSoC5/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 750:.\Generated_Source\PSoC5/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:.\Generated_Source\PSoC5/UART_1.c ****     *  have remained in the RAM.
 752:.\Generated_Source\PSoC5/UART_1.c ****     *
 753:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
 754:.\Generated_Source\PSoC5/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 755:.\Generated_Source\PSoC5/UART_1.c ****     *
 756:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 757:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 758:.\Generated_Source\PSoC5/UART_1.c ****     {
 759:.\Generated_Source\PSoC5/UART_1.c ****         uint8 enableInterrupts;
 760:.\Generated_Source\PSoC5/UART_1.c **** 
 761:.\Generated_Source\PSoC5/UART_1.c ****         /* Clear the HW FIFO */
 762:.\Generated_Source\PSoC5/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 763:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |= (uint8)  UART_1_RX_FIFO_CLR;
 764:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8) ~UART_1_RX_FIFO_CLR;
 765:.\Generated_Source\PSoC5/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 766:.\Generated_Source\PSoC5/UART_1.c **** 
 767:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 768:.\Generated_Source\PSoC5/UART_1.c **** 
 769:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt. */
 770:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableRxInt();
 771:.\Generated_Source\PSoC5/UART_1.c **** 
 772:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferRead = 0u;
 773:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferWrite = 0u;
 774:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferLoopDetect = 0u;
 775:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_rxBufferOverflow = 0u;
 776:.\Generated_Source\PSoC5/UART_1.c **** 
 777:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableRxInt();
 778:.\Generated_Source\PSoC5/UART_1.c **** 
 779:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 780:.\Generated_Source\PSoC5/UART_1.c **** 
 781:.\Generated_Source\PSoC5/UART_1.c ****     }
 782:.\Generated_Source\PSoC5/UART_1.c **** 
 783:.\Generated_Source\PSoC5/UART_1.c **** 
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 20


 784:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 785:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 786:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 787:.\Generated_Source\PSoC5/UART_1.c ****     *
 788:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 789:.\Generated_Source\PSoC5/UART_1.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:.\Generated_Source\PSoC5/UART_1.c ****     *  UART.
 791:.\Generated_Source\PSoC5/UART_1.c ****     *
 792:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 793:.\Generated_Source\PSoC5/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:.\Generated_Source\PSoC5/UART_1.c ****     *                                               detection
 796:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:.\Generated_Source\PSoC5/UART_1.c ****     *                                               address detection
 798:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:.\Generated_Source\PSoC5/UART_1.c ****     *                                               detection
 800:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:.\Generated_Source\PSoC5/UART_1.c ****     *                                               address detection
 802:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 803:.\Generated_Source\PSoC5/UART_1.c ****     *
 804:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 805:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 806:.\Generated_Source\PSoC5/UART_1.c ****     *
 807:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 808:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 809:.\Generated_Source\PSoC5/UART_1.c ****     *   the farther usage in RX ISR.
 810:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 811:.\Generated_Source\PSoC5/UART_1.c ****     *
 812:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 813:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 814:.\Generated_Source\PSoC5/UART_1.c ****                                                         
 815:.\Generated_Source\PSoC5/UART_1.c ****     {
 816:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 817:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 818:.\Generated_Source\PSoC5/UART_1.c ****                 if(0u != addressMode)
 819:.\Generated_Source\PSoC5/UART_1.c ****                 {
 820:.\Generated_Source\PSoC5/UART_1.c ****                     /* Suppress compiler warning */
 821:.\Generated_Source\PSoC5/UART_1.c ****                 }
 822:.\Generated_Source\PSoC5/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 823:.\Generated_Source\PSoC5/UART_1.c ****                 uint8 tmpCtrl;
 824:.\Generated_Source\PSoC5/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 825:.\Generated_Source\PSoC5/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 826:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 827:.\Generated_Source\PSoC5/UART_1.c **** 
 828:.\Generated_Source\PSoC5/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 829:.\Generated_Source\PSoC5/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 830:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 831:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 832:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 833:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 834:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 835:.\Generated_Source\PSoC5/UART_1.c ****             if(0u != addressMode)
 836:.\Generated_Source\PSoC5/UART_1.c ****             {
 837:.\Generated_Source\PSoC5/UART_1.c ****                 /* Suppress compiler warning */
 838:.\Generated_Source\PSoC5/UART_1.c ****             }
 839:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 840:.\Generated_Source\PSoC5/UART_1.c ****     }
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 21


 841:.\Generated_Source\PSoC5/UART_1.c **** 
 842:.\Generated_Source\PSoC5/UART_1.c **** 
 843:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 844:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 845:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 846:.\Generated_Source\PSoC5/UART_1.c ****     *
 847:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 848:.\Generated_Source\PSoC5/UART_1.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:.\Generated_Source\PSoC5/UART_1.c ****     *
 850:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 851:.\Generated_Source\PSoC5/UART_1.c ****     *  address: Address #1 for hardware address detection.
 852:.\Generated_Source\PSoC5/UART_1.c ****     *
 853:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 854:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 855:.\Generated_Source\PSoC5/UART_1.c ****     *
 856:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 857:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 858:.\Generated_Source\PSoC5/UART_1.c ****     {
 859:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 860:.\Generated_Source\PSoC5/UART_1.c ****     }
 861:.\Generated_Source\PSoC5/UART_1.c **** 
 862:.\Generated_Source\PSoC5/UART_1.c **** 
 863:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 864:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 865:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 866:.\Generated_Source\PSoC5/UART_1.c ****     *
 867:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 868:.\Generated_Source\PSoC5/UART_1.c ****     *  Sets the second of two hardware-detectable receiver addresses.
 869:.\Generated_Source\PSoC5/UART_1.c ****     *
 870:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 871:.\Generated_Source\PSoC5/UART_1.c ****     *  address: Address #2 for hardware address detection.
 872:.\Generated_Source\PSoC5/UART_1.c ****     *
 873:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 874:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 875:.\Generated_Source\PSoC5/UART_1.c ****     *
 876:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 877:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 878:.\Generated_Source\PSoC5/UART_1.c ****     {
 879:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 880:.\Generated_Source\PSoC5/UART_1.c ****     }
 881:.\Generated_Source\PSoC5/UART_1.c **** 
 882:.\Generated_Source\PSoC5/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 883:.\Generated_Source\PSoC5/UART_1.c **** 
 884:.\Generated_Source\PSoC5/UART_1.c **** 
 885:.\Generated_Source\PSoC5/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 886:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 887:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 888:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 889:.\Generated_Source\PSoC5/UART_1.c ****     *
 890:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 891:.\Generated_Source\PSoC5/UART_1.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
 892:.\Generated_Source\PSoC5/UART_1.c ****     *  interrupt.
 893:.\Generated_Source\PSoC5/UART_1.c ****     *
 894:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 895:.\Generated_Source\PSoC5/UART_1.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 22


 898:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:.\Generated_Source\PSoC5/UART_1.c ****     *
 901:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 902:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 903:.\Generated_Source\PSoC5/UART_1.c ****     *
 904:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 905:.\Generated_Source\PSoC5/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:.\Generated_Source\PSoC5/UART_1.c ****     *
 907:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 908:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 909:.\Generated_Source\PSoC5/UART_1.c ****     {
 301              		.loc 1 909 0
 302              		.cfi_startproc
 303              		@ args = 0, pretend = 0, frame = 8
 304              		@ frame_needed = 1, uses_anonymous_args = 0
 305              		@ link register save eliminated.
 306 0000 80B4     		push	{r7}
 307              		.cfi_def_cfa_offset 4
 308              		.cfi_offset 7, -4
 309 0002 83B0     		sub	sp, sp, #12
 310              		.cfi_def_cfa_offset 16
 311 0004 00AF     		add	r7, sp, #0
 312              		.cfi_def_cfa_register 7
 313 0006 0346     		mov	r3, r0
 314 0008 FB71     		strb	r3, [r7, #7]
 910:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 315              		.loc 1 910 0
 316 000a 044A     		ldr	r2, .L18
 317 000c FB79     		ldrb	r3, [r7, #7]
 318 000e 1370     		strb	r3, [r2]
 911:.\Generated_Source\PSoC5/UART_1.c ****     }
 319              		.loc 1 911 0
 320 0010 0C37     		adds	r7, r7, #12
 321              		.cfi_def_cfa_offset 4
 322 0012 BD46     		mov	sp, r7
 323              		.cfi_def_cfa_register 13
 324              		@ sp needed
 325 0014 5DF8047B 		ldr	r7, [sp], #4
 326              		.cfi_restore 7
 327              		.cfi_def_cfa_offset 0
 328 0018 7047     		bx	lr
 329              	.L19:
 330 001a 00BF     		.align	2
 331              	.L18:
 332 001c 82640040 		.word	1073767554
 333              		.cfi_endproc
 334              	.LFE6:
 335              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 336              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 337              		.align	2
 338              		.global	UART_1_WriteTxData
 339              		.thumb
 340              		.thumb_func
 341              		.type	UART_1_WriteTxData, %function
 342              	UART_1_WriteTxData:
 343              	.LFB7:
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 23


 912:.\Generated_Source\PSoC5/UART_1.c **** 
 913:.\Generated_Source\PSoC5/UART_1.c **** 
 914:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 915:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_WriteTxData
 916:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 917:.\Generated_Source\PSoC5/UART_1.c ****     *
 918:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 919:.\Generated_Source\PSoC5/UART_1.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:.\Generated_Source\PSoC5/UART_1.c ****     *  available without checking the TX status register. You must check status
 921:.\Generated_Source\PSoC5/UART_1.c ****     *  separately.
 922:.\Generated_Source\PSoC5/UART_1.c ****     *
 923:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 924:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: data byte
 925:.\Generated_Source\PSoC5/UART_1.c ****     *
 926:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 927:.\Generated_Source\PSoC5/UART_1.c ****     * None.
 928:.\Generated_Source\PSoC5/UART_1.c ****     *
 929:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
 930:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 931:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 932:.\Generated_Source\PSoC5/UART_1.c ****     *    incremented after each byte saved to buffer.
 933:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 934:.\Generated_Source\PSoC5/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 936:.\Generated_Source\PSoC5/UART_1.c ****     *    initialized.
 937:.\Generated_Source\PSoC5/UART_1.c ****     *
 938:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
 939:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
 940:.\Generated_Source\PSoC5/UART_1.c ****     *
 941:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
 942:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
 943:.\Generated_Source\PSoC5/UART_1.c ****     {
 344              		.loc 1 943 0
 345              		.cfi_startproc
 346              		@ args = 0, pretend = 0, frame = 8
 347              		@ frame_needed = 1, uses_anonymous_args = 0
 348              		@ link register save eliminated.
 349 0000 80B4     		push	{r7}
 350              		.cfi_def_cfa_offset 4
 351              		.cfi_offset 7, -4
 352 0002 83B0     		sub	sp, sp, #12
 353              		.cfi_def_cfa_offset 16
 354 0004 00AF     		add	r7, sp, #0
 355              		.cfi_def_cfa_register 7
 356 0006 0346     		mov	r3, r0
 357 0008 FB71     		strb	r3, [r7, #7]
 944:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
 945:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 358              		.loc 1 945 0
 359 000a 064B     		ldr	r3, .L22
 360 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 361 000e 002B     		cmp	r3, #0
 362 0010 02D0     		beq	.L20
 946:.\Generated_Source\PSoC5/UART_1.c ****         {
 947:.\Generated_Source\PSoC5/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 948:.\Generated_Source\PSoC5/UART_1.c **** 
 949:.\Generated_Source\PSoC5/UART_1.c ****             /* Protect variables that could change on interrupt. */
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 24


 950:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
 951:.\Generated_Source\PSoC5/UART_1.c **** 
 952:.\Generated_Source\PSoC5/UART_1.c ****             if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
 953:.\Generated_Source\PSoC5/UART_1.c ****                 ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
 954:.\Generated_Source\PSoC5/UART_1.c ****             {
 955:.\Generated_Source\PSoC5/UART_1.c ****                 /* Add directly to the FIFO. */
 956:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 957:.\Generated_Source\PSoC5/UART_1.c ****             }
 958:.\Generated_Source\PSoC5/UART_1.c ****             else
 959:.\Generated_Source\PSoC5/UART_1.c ****             {
 960:.\Generated_Source\PSoC5/UART_1.c ****                 if(UART_1_txBufferWrite >= UART_1_TX_BUFFER_SIZE)
 961:.\Generated_Source\PSoC5/UART_1.c ****                 {
 962:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBufferWrite = 0u;
 963:.\Generated_Source\PSoC5/UART_1.c ****                 }
 964:.\Generated_Source\PSoC5/UART_1.c **** 
 965:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
 966:.\Generated_Source\PSoC5/UART_1.c **** 
 967:.\Generated_Source\PSoC5/UART_1.c ****                 /* Add to the software buffer. */
 968:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_txBufferWrite++;
 969:.\Generated_Source\PSoC5/UART_1.c ****             }
 970:.\Generated_Source\PSoC5/UART_1.c **** 
 971:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
 972:.\Generated_Source\PSoC5/UART_1.c **** 
 973:.\Generated_Source\PSoC5/UART_1.c ****         #else
 974:.\Generated_Source\PSoC5/UART_1.c **** 
 975:.\Generated_Source\PSoC5/UART_1.c ****             /* Add directly to the FIFO. */
 976:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
 363              		.loc 1 976 0
 364 0012 054A     		ldr	r2, .L22+4
 365 0014 FB79     		ldrb	r3, [r7, #7]
 366 0016 1370     		strb	r3, [r2]
 367              	.L20:
 977:.\Generated_Source\PSoC5/UART_1.c **** 
 978:.\Generated_Source\PSoC5/UART_1.c ****         #endif /*(UART_1_TX_INTERRUPT_ENABLED) */
 979:.\Generated_Source\PSoC5/UART_1.c ****         }
 980:.\Generated_Source\PSoC5/UART_1.c ****     }
 368              		.loc 1 980 0
 369 0018 0C37     		adds	r7, r7, #12
 370              		.cfi_def_cfa_offset 4
 371 001a BD46     		mov	sp, r7
 372              		.cfi_def_cfa_register 13
 373              		@ sp needed
 374 001c 5DF8047B 		ldr	r7, [sp], #4
 375              		.cfi_restore 7
 376              		.cfi_def_cfa_offset 0
 377 0020 7047     		bx	lr
 378              	.L23:
 379 0022 00BF     		.align	2
 380              	.L22:
 381 0024 00000000 		.word	UART_1_initVar
 382 0028 43640040 		.word	1073767491
 383              		.cfi_endproc
 384              	.LFE7:
 385              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 386              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 387              		.align	2
 388              		.global	UART_1_ReadTxStatus
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 25


 389              		.thumb
 390              		.thumb_func
 391              		.type	UART_1_ReadTxStatus, %function
 392              	UART_1_ReadTxStatus:
 393              	.LFB8:
 981:.\Generated_Source\PSoC5/UART_1.c **** 
 982:.\Generated_Source\PSoC5/UART_1.c **** 
 983:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
 984:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
 985:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
 986:.\Generated_Source\PSoC5/UART_1.c ****     *
 987:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
 988:.\Generated_Source\PSoC5/UART_1.c ****     *  Reads the status register for the TX portion of the UART.
 989:.\Generated_Source\PSoC5/UART_1.c ****     *
 990:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
 991:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
 992:.\Generated_Source\PSoC5/UART_1.c ****     *
 993:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
 994:.\Generated_Source\PSoC5/UART_1.c ****     *  Contents of the status register
 995:.\Generated_Source\PSoC5/UART_1.c ****     *
 996:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
 997:.\Generated_Source\PSoC5/UART_1.c ****     *  This function reads the TX status register, which is cleared on read.
 998:.\Generated_Source\PSoC5/UART_1.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:.\Generated_Source\PSoC5/UART_1.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:.\Generated_Source\PSoC5/UART_1.c ****     *  and must be handled accordingly.
1001:.\Generated_Source\PSoC5/UART_1.c ****     *
1002:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1003:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1004:.\Generated_Source\PSoC5/UART_1.c ****     {
 394              		.loc 1 1004 0
 395              		.cfi_startproc
 396              		@ args = 0, pretend = 0, frame = 0
 397              		@ frame_needed = 1, uses_anonymous_args = 0
 398              		@ link register save eliminated.
 399 0000 80B4     		push	{r7}
 400              		.cfi_def_cfa_offset 4
 401              		.cfi_offset 7, -4
 402 0002 00AF     		add	r7, sp, #0
 403              		.cfi_def_cfa_register 7
1005:.\Generated_Source\PSoC5/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 404              		.loc 1 1005 0
 405 0004 034B     		ldr	r3, .L26
 406 0006 1B78     		ldrb	r3, [r3]
 407 0008 DBB2     		uxtb	r3, r3
1006:.\Generated_Source\PSoC5/UART_1.c ****     }
 408              		.loc 1 1006 0
 409 000a 1846     		mov	r0, r3
 410 000c BD46     		mov	sp, r7
 411              		.cfi_def_cfa_register 13
 412              		@ sp needed
 413 000e 5DF8047B 		ldr	r7, [sp], #4
 414              		.cfi_restore 7
 415              		.cfi_def_cfa_offset 0
 416 0012 7047     		bx	lr
 417              	.L27:
 418              		.align	2
 419              	.L26:
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 26


 420 0014 62640040 		.word	1073767522
 421              		.cfi_endproc
 422              	.LFE8:
 423              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 424              		.section	.text.UART_1_PutChar,"ax",%progbits
 425              		.align	2
 426              		.global	UART_1_PutChar
 427              		.thumb
 428              		.thumb_func
 429              		.type	UART_1_PutChar, %function
 430              	UART_1_PutChar:
 431              	.LFB9:
1007:.\Generated_Source\PSoC5/UART_1.c **** 
1008:.\Generated_Source\PSoC5/UART_1.c **** 
1009:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1010:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutChar
1011:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1012:.\Generated_Source\PSoC5/UART_1.c ****     *
1013:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1014:.\Generated_Source\PSoC5/UART_1.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:.\Generated_Source\PSoC5/UART_1.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:.\Generated_Source\PSoC5/UART_1.c ****     *  hold the data.
1017:.\Generated_Source\PSoC5/UART_1.c ****     *
1018:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1019:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: Byte containing the data to transmit
1020:.\Generated_Source\PSoC5/UART_1.c ****     *
1021:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1022:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1023:.\Generated_Source\PSoC5/UART_1.c ****     *
1024:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1025:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1026:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1027:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:.\Generated_Source\PSoC5/UART_1.c ****     *     saved to buffer.
1029:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1030:.\Generated_Source\PSoC5/UART_1.c ****     *     checked to identify free space in txBuffer.
1031:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1032:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1033:.\Generated_Source\PSoC5/UART_1.c ****     *
1034:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1035:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1036:.\Generated_Source\PSoC5/UART_1.c ****     *
1037:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1038:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1039:.\Generated_Source\PSoC5/UART_1.c ****     *
1040:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1041:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1042:.\Generated_Source\PSoC5/UART_1.c ****     {
 432              		.loc 1 1042 0
 433              		.cfi_startproc
 434              		@ args = 0, pretend = 0, frame = 8
 435              		@ frame_needed = 1, uses_anonymous_args = 0
 436              		@ link register save eliminated.
 437 0000 80B4     		push	{r7}
 438              		.cfi_def_cfa_offset 4
 439              		.cfi_offset 7, -4
 440 0002 83B0     		sub	sp, sp, #12
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 27


 441              		.cfi_def_cfa_offset 16
 442 0004 00AF     		add	r7, sp, #0
 443              		.cfi_def_cfa_register 7
 444 0006 0346     		mov	r3, r0
 445 0008 FB71     		strb	r3, [r7, #7]
1043:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1044:.\Generated_Source\PSoC5/UART_1.c ****         /* The temporary output pointer is used since it takes two instructions
1045:.\Generated_Source\PSoC5/UART_1.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:.\Generated_Source\PSoC5/UART_1.c ****         *  pointer and getting an interrupt in between instructions.
1047:.\Generated_Source\PSoC5/UART_1.c ****         */
1048:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locTxBufferWrite;
1049:.\Generated_Source\PSoC5/UART_1.c ****         uint8 locTxBufferRead;
1050:.\Generated_Source\PSoC5/UART_1.c **** 
1051:.\Generated_Source\PSoC5/UART_1.c ****         do
1052:.\Generated_Source\PSoC5/UART_1.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:.\Generated_Source\PSoC5/UART_1.c **** 
1054:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:.\Generated_Source\PSoC5/UART_1.c ****             /* Disable TX interrupt to protect variables from modification */
1056:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
1057:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1058:.\Generated_Source\PSoC5/UART_1.c **** 
1059:.\Generated_Source\PSoC5/UART_1.c ****             locTxBufferWrite = UART_1_txBufferWrite;
1060:.\Generated_Source\PSoC5/UART_1.c ****             locTxBufferRead  = UART_1_txBufferRead;
1061:.\Generated_Source\PSoC5/UART_1.c **** 
1062:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:.\Generated_Source\PSoC5/UART_1.c ****             /* Enable interrupt to continue transmission */
1064:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
1065:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1066:.\Generated_Source\PSoC5/UART_1.c ****         }
1067:.\Generated_Source\PSoC5/UART_1.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:.\Generated_Source\PSoC5/UART_1.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:.\Generated_Source\PSoC5/UART_1.c ****                                 (uint8)(UART_1_TX_BUFFER_SIZE - 1u)) );
1070:.\Generated_Source\PSoC5/UART_1.c **** 
1071:.\Generated_Source\PSoC5/UART_1.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
1072:.\Generated_Source\PSoC5/UART_1.c ****             ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1073:.\Generated_Source\PSoC5/UART_1.c ****         {
1074:.\Generated_Source\PSoC5/UART_1.c ****             /* Add directly to the FIFO */
1075:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
1076:.\Generated_Source\PSoC5/UART_1.c ****         }
1077:.\Generated_Source\PSoC5/UART_1.c ****         else
1078:.\Generated_Source\PSoC5/UART_1.c ****         {
1079:.\Generated_Source\PSoC5/UART_1.c ****             if(locTxBufferWrite >= UART_1_TX_BUFFER_SIZE)
1080:.\Generated_Source\PSoC5/UART_1.c ****             {
1081:.\Generated_Source\PSoC5/UART_1.c ****                 locTxBufferWrite = 0u;
1082:.\Generated_Source\PSoC5/UART_1.c ****             }
1083:.\Generated_Source\PSoC5/UART_1.c ****             /* Add to the software buffer. */
1084:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_txBuffer[locTxBufferWrite] = txDataByte;
1085:.\Generated_Source\PSoC5/UART_1.c ****             locTxBufferWrite++;
1086:.\Generated_Source\PSoC5/UART_1.c **** 
1087:.\Generated_Source\PSoC5/UART_1.c ****             /* Finally, update the real output pointer */
1088:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_DisableTxInt();
1090:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1091:.\Generated_Source\PSoC5/UART_1.c **** 
1092:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_txBufferWrite = locTxBufferWrite;
1093:.\Generated_Source\PSoC5/UART_1.c **** 
1094:.\Generated_Source\PSoC5/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 28


1095:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_EnableTxInt();
1096:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1097:.\Generated_Source\PSoC5/UART_1.c **** 
1098:.\Generated_Source\PSoC5/UART_1.c ****             if(0u != (UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_EMPTY))
1099:.\Generated_Source\PSoC5/UART_1.c ****             {
1100:.\Generated_Source\PSoC5/UART_1.c ****                 /* Trigger TX interrupt to send software buffer */
1101:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_SetPendingTxInt();
1102:.\Generated_Source\PSoC5/UART_1.c ****             }
1103:.\Generated_Source\PSoC5/UART_1.c ****         }
1104:.\Generated_Source\PSoC5/UART_1.c **** 
1105:.\Generated_Source\PSoC5/UART_1.c ****     #else
1106:.\Generated_Source\PSoC5/UART_1.c **** 
1107:.\Generated_Source\PSoC5/UART_1.c ****         while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 446              		.loc 1 1107 0
 447 000a 00BF     		nop
 448              	.L29:
 449              		.loc 1 1107 0 is_stmt 0 discriminator 1
 450 000c 074B     		ldr	r3, .L30
 451 000e 1B78     		ldrb	r3, [r3]
 452 0010 DBB2     		uxtb	r3, r3
 453 0012 03F00403 		and	r3, r3, #4
 454 0016 002B     		cmp	r3, #0
 455 0018 F8D1     		bne	.L29
1108:.\Generated_Source\PSoC5/UART_1.c ****         {
1109:.\Generated_Source\PSoC5/UART_1.c ****             /* Wait for room in the FIFO */
1110:.\Generated_Source\PSoC5/UART_1.c ****         }
1111:.\Generated_Source\PSoC5/UART_1.c **** 
1112:.\Generated_Source\PSoC5/UART_1.c ****         /* Add directly to the FIFO */
1113:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_REG = txDataByte;
 456              		.loc 1 1113 0 is_stmt 1
 457 001a 054A     		ldr	r2, .L30+4
 458 001c FB79     		ldrb	r3, [r7, #7]
 459 001e 1370     		strb	r3, [r2]
1114:.\Generated_Source\PSoC5/UART_1.c **** 
1115:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* UART_1_TX_INTERRUPT_ENABLED */
1116:.\Generated_Source\PSoC5/UART_1.c ****     }
 460              		.loc 1 1116 0
 461 0020 0C37     		adds	r7, r7, #12
 462              		.cfi_def_cfa_offset 4
 463 0022 BD46     		mov	sp, r7
 464              		.cfi_def_cfa_register 13
 465              		@ sp needed
 466 0024 5DF8047B 		ldr	r7, [sp], #4
 467              		.cfi_restore 7
 468              		.cfi_def_cfa_offset 0
 469 0028 7047     		bx	lr
 470              	.L31:
 471 002a 00BF     		.align	2
 472              	.L30:
 473 002c 62640040 		.word	1073767522
 474 0030 43640040 		.word	1073767491
 475              		.cfi_endproc
 476              	.LFE9:
 477              		.size	UART_1_PutChar, .-UART_1_PutChar
 478              		.section	.text.UART_1_PutString,"ax",%progbits
 479              		.align	2
 480              		.global	UART_1_PutString
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 29


 481              		.thumb
 482              		.thumb_func
 483              		.type	UART_1_PutString, %function
 484              	UART_1_PutString:
 485              	.LFB10:
1117:.\Generated_Source\PSoC5/UART_1.c **** 
1118:.\Generated_Source\PSoC5/UART_1.c **** 
1119:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1120:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutString
1121:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1122:.\Generated_Source\PSoC5/UART_1.c ****     *
1123:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1124:.\Generated_Source\PSoC5/UART_1.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
1125:.\Generated_Source\PSoC5/UART_1.c ****     *
1126:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1127:.\Generated_Source\PSoC5/UART_1.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:.\Generated_Source\PSoC5/UART_1.c ****     *
1129:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1130:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1131:.\Generated_Source\PSoC5/UART_1.c ****     *
1132:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1133:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1134:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1135:.\Generated_Source\PSoC5/UART_1.c ****     *
1136:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1137:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1138:.\Generated_Source\PSoC5/UART_1.c ****     *
1139:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1140:.\Generated_Source\PSoC5/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:.\Generated_Source\PSoC5/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1142:.\Generated_Source\PSoC5/UART_1.c ****     *  TX buffer.
1143:.\Generated_Source\PSoC5/UART_1.c ****     *
1144:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1145:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1146:.\Generated_Source\PSoC5/UART_1.c ****     {
 486              		.loc 1 1146 0
 487              		.cfi_startproc
 488              		@ args = 0, pretend = 0, frame = 16
 489              		@ frame_needed = 1, uses_anonymous_args = 0
 490 0000 80B5     		push	{r7, lr}
 491              		.cfi_def_cfa_offset 8
 492              		.cfi_offset 7, -8
 493              		.cfi_offset 14, -4
 494 0002 84B0     		sub	sp, sp, #16
 495              		.cfi_def_cfa_offset 24
 496 0004 00AF     		add	r7, sp, #0
 497              		.cfi_def_cfa_register 7
 498 0006 7860     		str	r0, [r7, #4]
1147:.\Generated_Source\PSoC5/UART_1.c ****         uint16 bufIndex = 0u;
 499              		.loc 1 1147 0
 500 0008 0023     		movs	r3, #0
 501 000a FB81     		strh	r3, [r7, #14]	@ movhi
1148:.\Generated_Source\PSoC5/UART_1.c **** 
1149:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function */
1150:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 502              		.loc 1 1150 0
 503 000c 0B4B     		ldr	r3, .L36
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 30


 504 000e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 505 0010 002B     		cmp	r3, #0
 506 0012 10D0     		beq	.L32
1151:.\Generated_Source\PSoC5/UART_1.c ****         {
1152:.\Generated_Source\PSoC5/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:.\Generated_Source\PSoC5/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 507              		.loc 1 1153 0
 508 0014 09E0     		b	.L34
 509              	.L35:
1154:.\Generated_Source\PSoC5/UART_1.c ****             {
1155:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_PutChar((uint8)string[bufIndex]);
 510              		.loc 1 1155 0
 511 0016 FB89     		ldrh	r3, [r7, #14]
 512 0018 7A68     		ldr	r2, [r7, #4]
 513 001a 1344     		add	r3, r3, r2
 514 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 515 001e 1846     		mov	r0, r3
 516 0020 FFF7FEFF 		bl	UART_1_PutChar
1156:.\Generated_Source\PSoC5/UART_1.c ****                 bufIndex++;
 517              		.loc 1 1156 0
 518 0024 FB89     		ldrh	r3, [r7, #14]
 519 0026 0133     		adds	r3, r3, #1
 520 0028 FB81     		strh	r3, [r7, #14]	@ movhi
 521              	.L34:
1153:.\Generated_Source\PSoC5/UART_1.c ****             {
 522              		.loc 1 1153 0
 523 002a FB89     		ldrh	r3, [r7, #14]
 524 002c 7A68     		ldr	r2, [r7, #4]
 525 002e 1344     		add	r3, r3, r2
 526 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 527 0032 002B     		cmp	r3, #0
 528 0034 EFD1     		bne	.L35
 529              	.L32:
1157:.\Generated_Source\PSoC5/UART_1.c ****             }
1158:.\Generated_Source\PSoC5/UART_1.c ****         }
1159:.\Generated_Source\PSoC5/UART_1.c ****     }
 530              		.loc 1 1159 0
 531 0036 1037     		adds	r7, r7, #16
 532              		.cfi_def_cfa_offset 8
 533 0038 BD46     		mov	sp, r7
 534              		.cfi_def_cfa_register 13
 535              		@ sp needed
 536 003a 80BD     		pop	{r7, pc}
 537              	.L37:
 538              		.align	2
 539              	.L36:
 540 003c 00000000 		.word	UART_1_initVar
 541              		.cfi_endproc
 542              	.LFE10:
 543              		.size	UART_1_PutString, .-UART_1_PutString
 544              		.section	.text.UART_1_PutArray,"ax",%progbits
 545              		.align	2
 546              		.global	UART_1_PutArray
 547              		.thumb
 548              		.thumb_func
 549              		.type	UART_1_PutArray, %function
 550              	UART_1_PutArray:
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 31


 551              	.LFB11:
1160:.\Generated_Source\PSoC5/UART_1.c **** 
1161:.\Generated_Source\PSoC5/UART_1.c **** 
1162:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1163:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutArray
1164:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1165:.\Generated_Source\PSoC5/UART_1.c ****     *
1166:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1167:.\Generated_Source\PSoC5/UART_1.c ****     *  Places N bytes of data from a memory array into the TX buffer for
1168:.\Generated_Source\PSoC5/UART_1.c ****     *  transmission.
1169:.\Generated_Source\PSoC5/UART_1.c ****     *
1170:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1171:.\Generated_Source\PSoC5/UART_1.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:.\Generated_Source\PSoC5/UART_1.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:.\Generated_Source\PSoC5/UART_1.c ****     *             Size parameter.
1174:.\Generated_Source\PSoC5/UART_1.c ****     *
1175:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1176:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1177:.\Generated_Source\PSoC5/UART_1.c ****     *
1178:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1179:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1180:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1181:.\Generated_Source\PSoC5/UART_1.c ****     *
1182:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1183:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1184:.\Generated_Source\PSoC5/UART_1.c ****     *
1185:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1186:.\Generated_Source\PSoC5/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:.\Generated_Source\PSoC5/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1188:.\Generated_Source\PSoC5/UART_1.c ****     *  TX buffer.
1189:.\Generated_Source\PSoC5/UART_1.c ****     *
1190:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1191:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1192:.\Generated_Source\PSoC5/UART_1.c ****                                                                     
1193:.\Generated_Source\PSoC5/UART_1.c ****     {
 552              		.loc 1 1193 0
 553              		.cfi_startproc
 554              		@ args = 0, pretend = 0, frame = 16
 555              		@ frame_needed = 1, uses_anonymous_args = 0
 556 0000 80B5     		push	{r7, lr}
 557              		.cfi_def_cfa_offset 8
 558              		.cfi_offset 7, -8
 559              		.cfi_offset 14, -4
 560 0002 84B0     		sub	sp, sp, #16
 561              		.cfi_def_cfa_offset 24
 562 0004 00AF     		add	r7, sp, #0
 563              		.cfi_def_cfa_register 7
 564 0006 7860     		str	r0, [r7, #4]
 565 0008 0B46     		mov	r3, r1
 566 000a FB70     		strb	r3, [r7, #3]
1194:.\Generated_Source\PSoC5/UART_1.c ****         uint8 bufIndex = 0u;
 567              		.loc 1 1194 0
 568 000c 0023     		movs	r3, #0
 569 000e FB73     		strb	r3, [r7, #15]
1195:.\Generated_Source\PSoC5/UART_1.c **** 
1196:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function */
1197:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 32


 570              		.loc 1 1197 0
 571 0010 0A4B     		ldr	r3, .L42
 572 0012 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 573 0014 002B     		cmp	r3, #0
 574 0016 0ED0     		beq	.L38
1198:.\Generated_Source\PSoC5/UART_1.c ****         {
1199:.\Generated_Source\PSoC5/UART_1.c ****             while(bufIndex < byteCount)
 575              		.loc 1 1199 0
 576 0018 09E0     		b	.L40
 577              	.L41:
1200:.\Generated_Source\PSoC5/UART_1.c ****             {
1201:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_PutChar(string[bufIndex]);
 578              		.loc 1 1201 0
 579 001a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 580 001c 7A68     		ldr	r2, [r7, #4]
 581 001e 1344     		add	r3, r3, r2
 582 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 583 0022 1846     		mov	r0, r3
 584 0024 FFF7FEFF 		bl	UART_1_PutChar
1202:.\Generated_Source\PSoC5/UART_1.c ****                 bufIndex++;
 585              		.loc 1 1202 0
 586 0028 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 587 002a 0133     		adds	r3, r3, #1
 588 002c FB73     		strb	r3, [r7, #15]
 589              	.L40:
1199:.\Generated_Source\PSoC5/UART_1.c ****             {
 590              		.loc 1 1199 0
 591 002e FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 592 0030 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 593 0032 9A42     		cmp	r2, r3
 594 0034 F1D3     		bcc	.L41
 595              	.L38:
1203:.\Generated_Source\PSoC5/UART_1.c ****             }
1204:.\Generated_Source\PSoC5/UART_1.c ****         }
1205:.\Generated_Source\PSoC5/UART_1.c ****     }
 596              		.loc 1 1205 0
 597 0036 1037     		adds	r7, r7, #16
 598              		.cfi_def_cfa_offset 8
 599 0038 BD46     		mov	sp, r7
 600              		.cfi_def_cfa_register 13
 601              		@ sp needed
 602 003a 80BD     		pop	{r7, pc}
 603              	.L43:
 604              		.align	2
 605              	.L42:
 606 003c 00000000 		.word	UART_1_initVar
 607              		.cfi_endproc
 608              	.LFE11:
 609              		.size	UART_1_PutArray, .-UART_1_PutArray
 610              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 611              		.align	2
 612              		.global	UART_1_PutCRLF
 613              		.thumb
 614              		.thumb_func
 615              		.type	UART_1_PutCRLF, %function
 616              	UART_1_PutCRLF:
 617              	.LFB12:
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 33


1206:.\Generated_Source\PSoC5/UART_1.c **** 
1207:.\Generated_Source\PSoC5/UART_1.c **** 
1208:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1209:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_PutCRLF
1210:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1211:.\Generated_Source\PSoC5/UART_1.c ****     *
1212:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1213:.\Generated_Source\PSoC5/UART_1.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:.\Generated_Source\PSoC5/UART_1.c ****     *  (0x0A) to the transmit buffer.
1215:.\Generated_Source\PSoC5/UART_1.c ****     *
1216:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1217:.\Generated_Source\PSoC5/UART_1.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:.\Generated_Source\PSoC5/UART_1.c ****     *
1219:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1220:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1221:.\Generated_Source\PSoC5/UART_1.c ****     *
1222:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1223:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1224:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1225:.\Generated_Source\PSoC5/UART_1.c ****     *
1226:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1227:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1228:.\Generated_Source\PSoC5/UART_1.c ****     *
1229:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1230:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1231:.\Generated_Source\PSoC5/UART_1.c ****     {
 618              		.loc 1 1231 0
 619              		.cfi_startproc
 620              		@ args = 0, pretend = 0, frame = 8
 621              		@ frame_needed = 1, uses_anonymous_args = 0
 622 0000 80B5     		push	{r7, lr}
 623              		.cfi_def_cfa_offset 8
 624              		.cfi_offset 7, -8
 625              		.cfi_offset 14, -4
 626 0002 82B0     		sub	sp, sp, #8
 627              		.cfi_def_cfa_offset 16
 628 0004 00AF     		add	r7, sp, #0
 629              		.cfi_def_cfa_register 7
 630 0006 0346     		mov	r3, r0
 631 0008 FB71     		strb	r3, [r7, #7]
1232:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function */
1233:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 632              		.loc 1 1233 0
 633 000a 084B     		ldr	r3, .L46
 634 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 635 000e 002B     		cmp	r3, #0
 636 0010 09D0     		beq	.L44
1234:.\Generated_Source\PSoC5/UART_1.c ****         {
1235:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(txDataByte);
 637              		.loc 1 1235 0
 638 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 639 0014 1846     		mov	r0, r3
 640 0016 FFF7FEFF 		bl	UART_1_PutChar
1236:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(0x0Du);
 641              		.loc 1 1236 0
 642 001a 0D20     		movs	r0, #13
 643 001c FFF7FEFF 		bl	UART_1_PutChar
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 34


1237:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_PutChar(0x0Au);
 644              		.loc 1 1237 0
 645 0020 0A20     		movs	r0, #10
 646 0022 FFF7FEFF 		bl	UART_1_PutChar
 647              	.L44:
1238:.\Generated_Source\PSoC5/UART_1.c ****         }
1239:.\Generated_Source\PSoC5/UART_1.c ****     }
 648              		.loc 1 1239 0
 649 0026 0837     		adds	r7, r7, #8
 650              		.cfi_def_cfa_offset 8
 651 0028 BD46     		mov	sp, r7
 652              		.cfi_def_cfa_register 13
 653              		@ sp needed
 654 002a 80BD     		pop	{r7, pc}
 655              	.L47:
 656              		.align	2
 657              	.L46:
 658 002c 00000000 		.word	UART_1_initVar
 659              		.cfi_endproc
 660              	.LFE12:
 661              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 662              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 663              		.align	2
 664              		.global	UART_1_GetTxBufferSize
 665              		.thumb
 666              		.thumb_func
 667              		.type	UART_1_GetTxBufferSize, %function
 668              	UART_1_GetTxBufferSize:
 669              	.LFB13:
1240:.\Generated_Source\PSoC5/UART_1.c **** 
1241:.\Generated_Source\PSoC5/UART_1.c **** 
1242:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1243:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1244:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1245:.\Generated_Source\PSoC5/UART_1.c ****     *
1246:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1247:.\Generated_Source\PSoC5/UART_1.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:.\Generated_Source\PSoC5/UART_1.c ****     *  transmitted.
1249:.\Generated_Source\PSoC5/UART_1.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:.\Generated_Source\PSoC5/UART_1.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:.\Generated_Source\PSoC5/UART_1.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:.\Generated_Source\PSoC5/UART_1.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:.\Generated_Source\PSoC5/UART_1.c ****     *    TX FIFO do not count.
1254:.\Generated_Source\PSoC5/UART_1.c ****     *
1255:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1256:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1257:.\Generated_Source\PSoC5/UART_1.c ****     *
1258:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1259:.\Generated_Source\PSoC5/UART_1.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:.\Generated_Source\PSoC5/UART_1.c ****     *  Buffer Size parameter.
1261:.\Generated_Source\PSoC5/UART_1.c ****     *
1262:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1263:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1264:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1265:.\Generated_Source\PSoC5/UART_1.c ****     *
1266:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1267:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 35


1268:.\Generated_Source\PSoC5/UART_1.c ****     *
1269:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1270:.\Generated_Source\PSoC5/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:.\Generated_Source\PSoC5/UART_1.c ****     *
1272:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC5/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1274:.\Generated_Source\PSoC5/UART_1.c ****                                                             
1275:.\Generated_Source\PSoC5/UART_1.c ****     {
 670              		.loc 1 1275 0
 671              		.cfi_startproc
 672              		@ args = 0, pretend = 0, frame = 8
 673              		@ frame_needed = 1, uses_anonymous_args = 0
 674              		@ link register save eliminated.
 675 0000 80B4     		push	{r7}
 676              		.cfi_def_cfa_offset 4
 677              		.cfi_offset 7, -4
 678 0002 83B0     		sub	sp, sp, #12
 679              		.cfi_def_cfa_offset 16
 680 0004 00AF     		add	r7, sp, #0
 681              		.cfi_def_cfa_register 7
1276:.\Generated_Source\PSoC5/UART_1.c ****         uint8 size;
1277:.\Generated_Source\PSoC5/UART_1.c **** 
1278:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1279:.\Generated_Source\PSoC5/UART_1.c **** 
1280:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt. */
1281:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableTxInt();
1282:.\Generated_Source\PSoC5/UART_1.c **** 
1283:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_txBufferRead == UART_1_txBufferWrite)
1284:.\Generated_Source\PSoC5/UART_1.c ****         {
1285:.\Generated_Source\PSoC5/UART_1.c ****             size = 0u;
1286:.\Generated_Source\PSoC5/UART_1.c ****         }
1287:.\Generated_Source\PSoC5/UART_1.c ****         else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1288:.\Generated_Source\PSoC5/UART_1.c ****         {
1289:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1290:.\Generated_Source\PSoC5/UART_1.c ****         }
1291:.\Generated_Source\PSoC5/UART_1.c ****         else
1292:.\Generated_Source\PSoC5/UART_1.c ****         {
1293:.\Generated_Source\PSoC5/UART_1.c ****             size = (UART_1_TX_BUFFER_SIZE - UART_1_txBufferRead) +
1294:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_txBufferWrite;
1295:.\Generated_Source\PSoC5/UART_1.c ****         }
1296:.\Generated_Source\PSoC5/UART_1.c **** 
1297:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableTxInt();
1298:.\Generated_Source\PSoC5/UART_1.c **** 
1299:.\Generated_Source\PSoC5/UART_1.c ****     #else
1300:.\Generated_Source\PSoC5/UART_1.c **** 
1301:.\Generated_Source\PSoC5/UART_1.c ****         size = UART_1_TXSTATUS_REG;
 682              		.loc 1 1301 0
 683 0006 0E4B     		ldr	r3, .L53
 684 0008 1B78     		ldrb	r3, [r3]
 685 000a FB71     		strb	r3, [r7, #7]
1302:.\Generated_Source\PSoC5/UART_1.c **** 
1303:.\Generated_Source\PSoC5/UART_1.c ****         /* Is the fifo is full. */
1304:.\Generated_Source\PSoC5/UART_1.c ****         if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 686              		.loc 1 1304 0
 687 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 688 000e 03F00403 		and	r3, r3, #4
 689 0012 002B     		cmp	r3, #0
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 36


 690 0014 02D0     		beq	.L49
1305:.\Generated_Source\PSoC5/UART_1.c ****         {
1306:.\Generated_Source\PSoC5/UART_1.c ****             size = UART_1_FIFO_LENGTH;
 691              		.loc 1 1306 0
 692 0016 0423     		movs	r3, #4
 693 0018 FB71     		strb	r3, [r7, #7]
 694 001a 09E0     		b	.L50
 695              	.L49:
1307:.\Generated_Source\PSoC5/UART_1.c ****         }
1308:.\Generated_Source\PSoC5/UART_1.c ****         else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 696              		.loc 1 1308 0
 697 001c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 698 001e 03F00203 		and	r3, r3, #2
 699 0022 002B     		cmp	r3, #0
 700 0024 02D0     		beq	.L51
1309:.\Generated_Source\PSoC5/UART_1.c ****         {
1310:.\Generated_Source\PSoC5/UART_1.c ****             size = 0u;
 701              		.loc 1 1310 0
 702 0026 0023     		movs	r3, #0
 703 0028 FB71     		strb	r3, [r7, #7]
 704 002a 01E0     		b	.L50
 705              	.L51:
1311:.\Generated_Source\PSoC5/UART_1.c ****         }
1312:.\Generated_Source\PSoC5/UART_1.c ****         else
1313:.\Generated_Source\PSoC5/UART_1.c ****         {
1314:.\Generated_Source\PSoC5/UART_1.c ****             /* We only know there is data in the fifo. */
1315:.\Generated_Source\PSoC5/UART_1.c ****             size = 1u;
 706              		.loc 1 1315 0
 707 002c 0123     		movs	r3, #1
 708 002e FB71     		strb	r3, [r7, #7]
 709              	.L50:
1316:.\Generated_Source\PSoC5/UART_1.c ****         }
1317:.\Generated_Source\PSoC5/UART_1.c **** 
1318:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1319:.\Generated_Source\PSoC5/UART_1.c **** 
1320:.\Generated_Source\PSoC5/UART_1.c ****     return(size);
 710              		.loc 1 1320 0
 711 0030 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
1321:.\Generated_Source\PSoC5/UART_1.c ****     }
 712              		.loc 1 1321 0
 713 0032 1846     		mov	r0, r3
 714 0034 0C37     		adds	r7, r7, #12
 715              		.cfi_def_cfa_offset 4
 716 0036 BD46     		mov	sp, r7
 717              		.cfi_def_cfa_register 13
 718              		@ sp needed
 719 0038 5DF8047B 		ldr	r7, [sp], #4
 720              		.cfi_restore 7
 721              		.cfi_def_cfa_offset 0
 722 003c 7047     		bx	lr
 723              	.L54:
 724 003e 00BF     		.align	2
 725              	.L53:
 726 0040 62640040 		.word	1073767522
 727              		.cfi_endproc
 728              	.LFE13:
 729              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 37


 730              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 731              		.align	2
 732              		.global	UART_1_ClearTxBuffer
 733              		.thumb
 734              		.thumb_func
 735              		.type	UART_1_ClearTxBuffer, %function
 736              	UART_1_ClearTxBuffer:
 737              	.LFB14:
1322:.\Generated_Source\PSoC5/UART_1.c **** 
1323:.\Generated_Source\PSoC5/UART_1.c **** 
1324:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1325:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1326:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1327:.\Generated_Source\PSoC5/UART_1.c ****     *
1328:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1329:.\Generated_Source\PSoC5/UART_1.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:.\Generated_Source\PSoC5/UART_1.c ****     *
1331:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1332:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1333:.\Generated_Source\PSoC5/UART_1.c ****     *
1334:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1335:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1336:.\Generated_Source\PSoC5/UART_1.c ****     *
1337:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1338:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1339:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1340:.\Generated_Source\PSoC5/UART_1.c ****     *
1341:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1342:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1343:.\Generated_Source\PSoC5/UART_1.c ****     *
1344:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1345:.\Generated_Source\PSoC5/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:.\Generated_Source\PSoC5/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:.\Generated_Source\PSoC5/UART_1.c ****     *  remained in the RAM.
1348:.\Generated_Source\PSoC5/UART_1.c ****     *
1349:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1350:.\Generated_Source\PSoC5/UART_1.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:.\Generated_Source\PSoC5/UART_1.c ****     *  transmitting finishes transmitting.
1352:.\Generated_Source\PSoC5/UART_1.c ****     *
1353:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1354:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1355:.\Generated_Source\PSoC5/UART_1.c ****     {
 738              		.loc 1 1355 0
 739              		.cfi_startproc
 740              		@ args = 0, pretend = 0, frame = 8
 741              		@ frame_needed = 1, uses_anonymous_args = 0
 742 0000 80B5     		push	{r7, lr}
 743              		.cfi_def_cfa_offset 8
 744              		.cfi_offset 7, -8
 745              		.cfi_offset 14, -4
 746 0002 82B0     		sub	sp, sp, #8
 747              		.cfi_def_cfa_offset 16
 748 0004 00AF     		add	r7, sp, #0
 749              		.cfi_def_cfa_register 7
1356:.\Generated_Source\PSoC5/UART_1.c ****         uint8 enableInterrupts;
1357:.\Generated_Source\PSoC5/UART_1.c **** 
1358:.\Generated_Source\PSoC5/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 38


 750              		.loc 1 1358 0
 751 0006 FFF7FEFF 		bl	CyEnterCriticalSection
 752 000a 0346     		mov	r3, r0
 753 000c FB71     		strb	r3, [r7, #7]
1359:.\Generated_Source\PSoC5/UART_1.c ****         /* Clear the HW FIFO */
1360:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |= (uint8)  UART_1_TX_FIFO_CLR;
 754              		.loc 1 1360 0
 755 000e 0B4A     		ldr	r2, .L56
 756 0010 0A4B     		ldr	r3, .L56
 757 0012 1B78     		ldrb	r3, [r3]
 758 0014 DBB2     		uxtb	r3, r3
 759 0016 43F00103 		orr	r3, r3, #1
 760 001a DBB2     		uxtb	r3, r3
 761 001c 1370     		strb	r3, [r2]
1361:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8) ~UART_1_TX_FIFO_CLR;
 762              		.loc 1 1361 0
 763 001e 074A     		ldr	r2, .L56
 764 0020 064B     		ldr	r3, .L56
 765 0022 1B78     		ldrb	r3, [r3]
 766 0024 DBB2     		uxtb	r3, r3
 767 0026 23F00103 		bic	r3, r3, #1
 768 002a DBB2     		uxtb	r3, r3
 769 002c 1370     		strb	r3, [r2]
1362:.\Generated_Source\PSoC5/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 770              		.loc 1 1362 0
 771 002e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 772 0030 1846     		mov	r0, r3
 773 0032 FFF7FEFF 		bl	CyExitCriticalSection
1363:.\Generated_Source\PSoC5/UART_1.c **** 
1364:.\Generated_Source\PSoC5/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1365:.\Generated_Source\PSoC5/UART_1.c **** 
1366:.\Generated_Source\PSoC5/UART_1.c ****         /* Protect variables that could change on interrupt. */
1367:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_DisableTxInt();
1368:.\Generated_Source\PSoC5/UART_1.c **** 
1369:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_txBufferRead = 0u;
1370:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_txBufferWrite = 0u;
1371:.\Generated_Source\PSoC5/UART_1.c **** 
1372:.\Generated_Source\PSoC5/UART_1.c ****         /* Enable Tx interrupt. */
1373:.\Generated_Source\PSoC5/UART_1.c ****         UART_1_EnableTxInt();
1374:.\Generated_Source\PSoC5/UART_1.c **** 
1375:.\Generated_Source\PSoC5/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1376:.\Generated_Source\PSoC5/UART_1.c ****     }
 774              		.loc 1 1376 0
 775 0036 0837     		adds	r7, r7, #8
 776              		.cfi_def_cfa_offset 8
 777 0038 BD46     		mov	sp, r7
 778              		.cfi_def_cfa_register 13
 779              		@ sp needed
 780 003a 80BD     		pop	{r7, pc}
 781              	.L57:
 782              		.align	2
 783              	.L56:
 784 003c 93640040 		.word	1073767571
 785              		.cfi_endproc
 786              	.LFE14:
 787              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 788              		.section	.text.UART_1_SendBreak,"ax",%progbits
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 39


 789              		.align	2
 790              		.global	UART_1_SendBreak
 791              		.thumb
 792              		.thumb_func
 793              		.type	UART_1_SendBreak, %function
 794              	UART_1_SendBreak:
 795              	.LFB15:
1377:.\Generated_Source\PSoC5/UART_1.c **** 
1378:.\Generated_Source\PSoC5/UART_1.c **** 
1379:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1380:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SendBreak
1381:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1382:.\Generated_Source\PSoC5/UART_1.c ****     *
1383:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1384:.\Generated_Source\PSoC5/UART_1.c ****     *  Transmits a break signal on the bus.
1385:.\Generated_Source\PSoC5/UART_1.c ****     *
1386:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1387:.\Generated_Source\PSoC5/UART_1.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_SEND_BREAK - Initialize registers for break, send the Break
1389:.\Generated_Source\PSoC5/UART_1.c ****     *       signal and return immediately.
1390:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:.\Generated_Source\PSoC5/UART_1.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_REINIT - Reinitialize registers to normal transmission mode
1393:.\Generated_Source\PSoC5/UART_1.c ****     *       then return.
1394:.\Generated_Source\PSoC5/UART_1.c ****     *   UART_1_SEND_WAIT_REINIT - Performs both options: 
1395:.\Generated_Source\PSoC5/UART_1.c ****     *      UART_1_SEND_BREAK and UART_1_WAIT_FOR_COMPLETE_REINIT.
1396:.\Generated_Source\PSoC5/UART_1.c ****     *      This option is recommended for most cases.
1397:.\Generated_Source\PSoC5/UART_1.c ****     *
1398:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1399:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1400:.\Generated_Source\PSoC5/UART_1.c ****     *
1401:.\Generated_Source\PSoC5/UART_1.c ****     * Global Variables:
1402:.\Generated_Source\PSoC5/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1403:.\Generated_Source\PSoC5/UART_1.c ****     *     initialized.
1404:.\Generated_Source\PSoC5/UART_1.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
1405:.\Generated_Source\PSoC5/UART_1.c ****     *
1406:.\Generated_Source\PSoC5/UART_1.c ****     * Reentrant:
1407:.\Generated_Source\PSoC5/UART_1.c ****     *  No.
1408:.\Generated_Source\PSoC5/UART_1.c ****     *
1409:.\Generated_Source\PSoC5/UART_1.c ****     * Theory:
1410:.\Generated_Source\PSoC5/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:.\Generated_Source\PSoC5/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:.\Generated_Source\PSoC5/UART_1.c ****     *  operation.
1413:.\Generated_Source\PSoC5/UART_1.c ****     *  There are 3 variants for this API usage:
1414:.\Generated_Source\PSoC5/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:.\Generated_Source\PSoC5/UART_1.c ****     *     configuration returning. Function will block CPU until transmission
1416:.\Generated_Source\PSoC5/UART_1.c ****     *     complete.
1417:.\Generated_Source\PSoC5/UART_1.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:.\Generated_Source\PSoC5/UART_1.c ****     *     operation
1419:.\Generated_Source\PSoC5/UART_1.c ****     *     Example for this case:
1420:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:.\Generated_Source\PSoC5/UART_1.c ****     *         Add your code here to use CPU time
1422:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1423:.\Generated_Source\PSoC5/UART_1.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:.\Generated_Source\PSoC5/UART_1.c ****     *     complete break operation.
1425:.\Generated_Source\PSoC5/UART_1.c ****     *     Example for this case:
1426:.\Generated_Source\PSoC5/UART_1.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 40


1427:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1428:.\Generated_Source\PSoC5/UART_1.c ****     *         Add your code here to use CPU time
1429:.\Generated_Source\PSoC5/UART_1.c ****     *     When interrupt appear with UART_1_TX_STS_COMPLETE status:
1430:.\Generated_Source\PSoC5/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1431:.\Generated_Source\PSoC5/UART_1.c ****     *
1432:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1433:.\Generated_Source\PSoC5/UART_1.c ****     *  The UART_1_SendBreak() function initializes registers to send a
1434:.\Generated_Source\PSoC5/UART_1.c ****     *  break signal.
1435:.\Generated_Source\PSoC5/UART_1.c ****     *  Break signal length depends on the break signal bits configuration.
1436:.\Generated_Source\PSoC5/UART_1.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:.\Generated_Source\PSoC5/UART_1.c ****     *  communication can continue.
1438:.\Generated_Source\PSoC5/UART_1.c ****     *
1439:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1440:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1441:.\Generated_Source\PSoC5/UART_1.c ****     {
 796              		.loc 1 1441 0
 797              		.cfi_startproc
 798              		@ args = 0, pretend = 0, frame = 16
 799              		@ frame_needed = 1, uses_anonymous_args = 0
 800              		@ link register save eliminated.
 801 0000 80B4     		push	{r7}
 802              		.cfi_def_cfa_offset 4
 803              		.cfi_offset 7, -4
 804 0002 85B0     		sub	sp, sp, #20
 805              		.cfi_def_cfa_offset 24
 806 0004 00AF     		add	r7, sp, #0
 807              		.cfi_def_cfa_register 7
 808 0006 0346     		mov	r3, r0
 809 0008 FB71     		strb	r3, [r7, #7]
1442:.\Generated_Source\PSoC5/UART_1.c **** 
1443:.\Generated_Source\PSoC5/UART_1.c ****         /* If not Initialized then skip this function*/
1444:.\Generated_Source\PSoC5/UART_1.c ****         if(UART_1_initVar != 0u)
 810              		.loc 1 1444 0
 811 000a 1F4B     		ldr	r3, .L66
 812 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 813 000e 002B     		cmp	r3, #0
 814 0010 35D0     		beq	.L58
 815              	.LBB2:
1445:.\Generated_Source\PSoC5/UART_1.c ****         {
1446:.\Generated_Source\PSoC5/UART_1.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:.\Generated_Source\PSoC5/UART_1.c ****             /* When that is done then reset the counter value back */
1448:.\Generated_Source\PSoC5/UART_1.c ****             uint8 tmpStat;
1449:.\Generated_Source\PSoC5/UART_1.c **** 
1450:.\Generated_Source\PSoC5/UART_1.c ****         #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1451:.\Generated_Source\PSoC5/UART_1.c **** 
1452:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
1453:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT ) )
1454:.\Generated_Source\PSoC5/UART_1.c ****             {
1455:.\Generated_Source\PSoC5/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1457:.\Generated_Source\PSoC5/UART_1.c ****                                                       UART_1_CTRL_HD_SEND_BREAK);
1458:.\Generated_Source\PSoC5/UART_1.c ****                 /* Send zeros */
1459:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
1460:.\Generated_Source\PSoC5/UART_1.c **** 
1461:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit starts */
1462:.\Generated_Source\PSoC5/UART_1.c ****                 {
1463:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 41


1464:.\Generated_Source\PSoC5/UART_1.c ****                 }
1465:.\Generated_Source\PSoC5/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1466:.\Generated_Source\PSoC5/UART_1.c ****             }
1467:.\Generated_Source\PSoC5/UART_1.c **** 
1468:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1469:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1470:.\Generated_Source\PSoC5/UART_1.c ****             {
1471:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit complete */
1472:.\Generated_Source\PSoC5/UART_1.c ****                 {
1473:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1474:.\Generated_Source\PSoC5/UART_1.c ****                 }
1475:.\Generated_Source\PSoC5/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1476:.\Generated_Source\PSoC5/UART_1.c ****             }
1477:.\Generated_Source\PSoC5/UART_1.c **** 
1478:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1479:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_REINIT) ||
1480:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1481:.\Generated_Source\PSoC5/UART_1.c ****             {
1482:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1483:.\Generated_Source\PSoC5/UART_1.c ****                                               (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1484:.\Generated_Source\PSoC5/UART_1.c ****             }
1485:.\Generated_Source\PSoC5/UART_1.c **** 
1486:.\Generated_Source\PSoC5/UART_1.c ****         #else /* UART_1_HD_ENABLED Full Duplex mode */
1487:.\Generated_Source\PSoC5/UART_1.c **** 
1488:.\Generated_Source\PSoC5/UART_1.c ****             static uint8 txPeriod;
1489:.\Generated_Source\PSoC5/UART_1.c **** 
1490:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
 816              		.loc 1 1490 0
 817 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 818 0014 002B     		cmp	r3, #0
 819 0016 02D0     		beq	.L60
 820              		.loc 1 1490 0 is_stmt 0 discriminator 1
 821 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 822 001a 032B     		cmp	r3, #3
 823 001c 12D1     		bne	.L61
 824              	.L60:
1491:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1492:.\Generated_Source\PSoC5/UART_1.c ****             {
1493:.\Generated_Source\PSoC5/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:.\Generated_Source\PSoC5/UART_1.c ****                 #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1495:.\Generated_Source\PSoC5/UART_1.c ****                                     (UART_1_PARITY_TYPE_SW != 0u) )
1496:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1497:.\Generated_Source\PSoC5/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1498:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1499:.\Generated_Source\PSoC5/UART_1.c **** 
1500:.\Generated_Source\PSoC5/UART_1.c ****                 #if(UART_1_TXCLKGEN_DP)
1501:.\Generated_Source\PSoC5/UART_1.c ****                     txPeriod = UART_1_TXBITCLKTX_COMPLETE_REG;
1502:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
1503:.\Generated_Source\PSoC5/UART_1.c ****                 #else
1504:.\Generated_Source\PSoC5/UART_1.c ****                     txPeriod = UART_1_TXBITCTR_PERIOD_REG;
 825              		.loc 1 1504 0 is_stmt 1
 826 001e 1B4B     		ldr	r3, .L66+4
 827 0020 1B78     		ldrb	r3, [r3]
 828 0022 DAB2     		uxtb	r2, r3
 829 0024 1A4B     		ldr	r3, .L66+8
 830 0026 1A70     		strb	r2, [r3]
1505:.\Generated_Source\PSoC5/UART_1.c ****                     UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 42


 831              		.loc 1 1505 0
 832 0028 184B     		ldr	r3, .L66+4
 833 002a 6722     		movs	r2, #103
 834 002c 1A70     		strb	r2, [r3]
1506:.\Generated_Source\PSoC5/UART_1.c ****                 #endif /* End UART_1_TXCLKGEN_DP */
1507:.\Generated_Source\PSoC5/UART_1.c **** 
1508:.\Generated_Source\PSoC5/UART_1.c ****                 /* Send zeros */
1509:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
 835              		.loc 1 1509 0
 836 002e 194B     		ldr	r3, .L66+12
 837 0030 0022     		movs	r2, #0
 838 0032 1A70     		strb	r2, [r3]
 839              	.L62:
1510:.\Generated_Source\PSoC5/UART_1.c **** 
1511:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit starts */
1512:.\Generated_Source\PSoC5/UART_1.c ****                 {
1513:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 840              		.loc 1 1513 0 discriminator 1
 841 0034 184B     		ldr	r3, .L66+16
 842 0036 1B78     		ldrb	r3, [r3]
 843 0038 FB73     		strb	r3, [r7, #15]
1514:.\Generated_Source\PSoC5/UART_1.c ****                 }
1515:.\Generated_Source\PSoC5/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 844              		.loc 1 1515 0 discriminator 1
 845 003a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 846 003c 03F00203 		and	r3, r3, #2
 847 0040 002B     		cmp	r3, #0
 848 0042 F7D1     		bne	.L62
 849              	.L61:
1516:.\Generated_Source\PSoC5/UART_1.c ****             }
1517:.\Generated_Source\PSoC5/UART_1.c **** 
1518:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 850              		.loc 1 1518 0
 851 0044 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 852 0046 012B     		cmp	r3, #1
 853 0048 02D0     		beq	.L63
 854              		.loc 1 1518 0 is_stmt 0 discriminator 1
 855 004a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 856 004c 032B     		cmp	r3, #3
 857 004e 09D1     		bne	.L64
 858              	.L63:
1519:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1520:.\Generated_Source\PSoC5/UART_1.c ****             {
1521:.\Generated_Source\PSoC5/UART_1.c ****                 do /* Wait until transmit complete */
1522:.\Generated_Source\PSoC5/UART_1.c ****                 {
1523:.\Generated_Source\PSoC5/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 859              		.loc 1 1523 0 is_stmt 1 discriminator 1
 860 0050 114B     		ldr	r3, .L66+16
 861 0052 1B78     		ldrb	r3, [r3]
 862 0054 FB73     		strb	r3, [r7, #15]
1524:.\Generated_Source\PSoC5/UART_1.c ****                 }
1525:.\Generated_Source\PSoC5/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 863              		.loc 1 1525 0 discriminator 1
 864 0056 FB7B     		ldrb	r3, [r7, #15]
 865 0058 DB43     		mvns	r3, r3
 866 005a DBB2     		uxtb	r3, r3
 867 005c 03F00103 		and	r3, r3, #1
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 43


 868 0060 002B     		cmp	r3, #0
 869 0062 F5D1     		bne	.L63
 870              	.L64:
1526:.\Generated_Source\PSoC5/UART_1.c ****             }
1527:.\Generated_Source\PSoC5/UART_1.c **** 
1528:.\Generated_Source\PSoC5/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 871              		.loc 1 1528 0
 872 0064 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 873 0066 012B     		cmp	r3, #1
 874 0068 05D0     		beq	.L65
 875              		.loc 1 1528 0 is_stmt 0 discriminator 1
 876 006a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 877 006c 022B     		cmp	r3, #2
 878 006e 02D0     		beq	.L65
1529:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_REINIT) ||
 879              		.loc 1 1529 0 is_stmt 1
 880 0070 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 881 0072 032B     		cmp	r3, #3
 882 0074 03D1     		bne	.L58
 883              	.L65:
1530:.\Generated_Source\PSoC5/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1531:.\Generated_Source\PSoC5/UART_1.c ****             {
1532:.\Generated_Source\PSoC5/UART_1.c **** 
1533:.\Generated_Source\PSoC5/UART_1.c ****             #if(UART_1_TXCLKGEN_DP)
1534:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXBITCLKTX_COMPLETE_REG = txPeriod;
1535:.\Generated_Source\PSoC5/UART_1.c ****             #else
1536:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_TXBITCTR_PERIOD_REG = txPeriod;
 884              		.loc 1 1536 0
 885 0076 054B     		ldr	r3, .L66+4
 886 0078 054A     		ldr	r2, .L66+8
 887 007a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 888 007c 1A70     		strb	r2, [r3]
 889              	.L58:
 890              	.LBE2:
1537:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_TXCLKGEN_DP */
1538:.\Generated_Source\PSoC5/UART_1.c **** 
1539:.\Generated_Source\PSoC5/UART_1.c ****             #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1540:.\Generated_Source\PSoC5/UART_1.c ****                  (UART_1_PARITY_TYPE_SW != 0u) )
1541:.\Generated_Source\PSoC5/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1542:.\Generated_Source\PSoC5/UART_1.c ****                                                       (uint8) ~UART_1_CTRL_HD_SEND_BREAK);
1543:.\Generated_Source\PSoC5/UART_1.c ****             #endif /* End UART_1_PARITY_TYPE != NONE */
1544:.\Generated_Source\PSoC5/UART_1.c ****             }
1545:.\Generated_Source\PSoC5/UART_1.c ****         #endif    /* End UART_1_HD_ENABLED */
1546:.\Generated_Source\PSoC5/UART_1.c ****         }
1547:.\Generated_Source\PSoC5/UART_1.c ****     }
 891              		.loc 1 1547 0
 892 007e 1437     		adds	r7, r7, #20
 893              		.cfi_def_cfa_offset 4
 894 0080 BD46     		mov	sp, r7
 895              		.cfi_def_cfa_register 13
 896              		@ sp needed
 897 0082 5DF8047B 		ldr	r7, [sp], #4
 898              		.cfi_restore 7
 899              		.cfi_def_cfa_offset 0
 900 0086 7047     		bx	lr
 901              	.L67:
 902              		.align	2
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 44


 903              	.L66:
 904 0088 00000000 		.word	UART_1_initVar
 905 008c 83640040 		.word	1073767555
 906 0090 01000000 		.word	txPeriod.4914
 907 0094 43640040 		.word	1073767491
 908 0098 62640040 		.word	1073767522
 909              		.cfi_endproc
 910              	.LFE15:
 911              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 912              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 913              		.align	2
 914              		.global	UART_1_SetTxAddressMode
 915              		.thumb
 916              		.thumb_func
 917              		.type	UART_1_SetTxAddressMode, %function
 918              	UART_1_SetTxAddressMode:
 919              	.LFB16:
1548:.\Generated_Source\PSoC5/UART_1.c **** 
1549:.\Generated_Source\PSoC5/UART_1.c **** 
1550:.\Generated_Source\PSoC5/UART_1.c ****     /*******************************************************************************
1551:.\Generated_Source\PSoC5/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1552:.\Generated_Source\PSoC5/UART_1.c ****     ********************************************************************************
1553:.\Generated_Source\PSoC5/UART_1.c ****     *
1554:.\Generated_Source\PSoC5/UART_1.c ****     * Summary:
1555:.\Generated_Source\PSoC5/UART_1.c ****     *  Configures the transmitter to signal the next bytes is address or data.
1556:.\Generated_Source\PSoC5/UART_1.c ****     *
1557:.\Generated_Source\PSoC5/UART_1.c ****     * Parameters:
1558:.\Generated_Source\PSoC5/UART_1.c ****     *  addressMode: 
1559:.\Generated_Source\PSoC5/UART_1.c ****     *       UART_1_SET_SPACE - Configure the transmitter to send the next
1560:.\Generated_Source\PSoC5/UART_1.c ****     *                                    byte as a data.
1561:.\Generated_Source\PSoC5/UART_1.c ****     *       UART_1_SET_MARK  - Configure the transmitter to send the next
1562:.\Generated_Source\PSoC5/UART_1.c ****     *                                    byte as an address.
1563:.\Generated_Source\PSoC5/UART_1.c ****     *
1564:.\Generated_Source\PSoC5/UART_1.c ****     * Return:
1565:.\Generated_Source\PSoC5/UART_1.c ****     *  None.
1566:.\Generated_Source\PSoC5/UART_1.c ****     *
1567:.\Generated_Source\PSoC5/UART_1.c ****     * Side Effects:
1568:.\Generated_Source\PSoC5/UART_1.c ****     *  This function sets and clears UART_1_CTRL_MARK bit in the Control
1569:.\Generated_Source\PSoC5/UART_1.c ****     *  register.
1570:.\Generated_Source\PSoC5/UART_1.c ****     *
1571:.\Generated_Source\PSoC5/UART_1.c ****     *******************************************************************************/
1572:.\Generated_Source\PSoC5/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1573:.\Generated_Source\PSoC5/UART_1.c ****     {
 920              		.loc 1 1573 0
 921              		.cfi_startproc
 922              		@ args = 0, pretend = 0, frame = 8
 923              		@ frame_needed = 1, uses_anonymous_args = 0
 924              		@ link register save eliminated.
 925 0000 80B4     		push	{r7}
 926              		.cfi_def_cfa_offset 4
 927              		.cfi_offset 7, -4
 928 0002 83B0     		sub	sp, sp, #12
 929              		.cfi_def_cfa_offset 16
 930 0004 00AF     		add	r7, sp, #0
 931              		.cfi_def_cfa_register 7
 932 0006 0346     		mov	r3, r0
 933 0008 FB71     		strb	r3, [r7, #7]
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 45


1574:.\Generated_Source\PSoC5/UART_1.c ****         /* Mark/Space sending enable */
1575:.\Generated_Source\PSoC5/UART_1.c ****         if(addressMode != 0u)
1576:.\Generated_Source\PSoC5/UART_1.c ****         {
1577:.\Generated_Source\PSoC5/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1578:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1579:.\Generated_Source\PSoC5/UART_1.c ****                                                   UART_1_CTRL_MARK);
1580:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1581:.\Generated_Source\PSoC5/UART_1.c ****         }
1582:.\Generated_Source\PSoC5/UART_1.c ****         else
1583:.\Generated_Source\PSoC5/UART_1.c ****         {
1584:.\Generated_Source\PSoC5/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1585:.\Generated_Source\PSoC5/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1586:.\Generated_Source\PSoC5/UART_1.c ****                                                   (uint8) ~UART_1_CTRL_MARK);
1587:.\Generated_Source\PSoC5/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1588:.\Generated_Source\PSoC5/UART_1.c ****         }
1589:.\Generated_Source\PSoC5/UART_1.c ****     }
 934              		.loc 1 1589 0
 935 000a 0C37     		adds	r7, r7, #12
 936              		.cfi_def_cfa_offset 4
 937 000c BD46     		mov	sp, r7
 938              		.cfi_def_cfa_register 13
 939              		@ sp needed
 940 000e 5DF8047B 		ldr	r7, [sp], #4
 941              		.cfi_restore 7
 942              		.cfi_def_cfa_offset 0
 943 0012 7047     		bx	lr
 944              		.cfi_endproc
 945              	.LFE16:
 946              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 947              		.bss
 948              	txPeriod.4914:
 949 0001 00       		.space	1
 950              		.text
 951              	.Letext0:
 952              		.file 2 ".\\Generated_Source\\PSoC5\\cytypes.h"
 953              		.section	.debug_info,"",%progbits
 954              	.Ldebug_info0:
 955 0000 74030000 		.4byte	0x374
 956 0004 0400     		.2byte	0x4
 957 0006 00000000 		.4byte	.Ldebug_abbrev0
 958 000a 04       		.byte	0x4
 959 000b 01       		.uleb128 0x1
 960 000c 27010000 		.4byte	.LASF45
 961 0010 01       		.byte	0x1
 962 0011 B3020000 		.4byte	.LASF46
 963 0015 60020000 		.4byte	.LASF47
 964 0019 00000000 		.4byte	.Ldebug_ranges0+0
 965 001d 00000000 		.4byte	0
 966 0021 00000000 		.4byte	.Ldebug_line0
 967 0025 02       		.uleb128 0x2
 968 0026 01       		.byte	0x1
 969 0027 06       		.byte	0x6
 970 0028 45030000 		.4byte	.LASF0
 971 002c 02       		.uleb128 0x2
 972 002d 01       		.byte	0x1
 973 002e 08       		.byte	0x8
 974 002f 19010000 		.4byte	.LASF1
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 46


 975 0033 02       		.uleb128 0x2
 976 0034 02       		.byte	0x2
 977 0035 05       		.byte	0x5
 978 0036 C3010000 		.4byte	.LASF2
 979 003a 02       		.uleb128 0x2
 980 003b 02       		.byte	0x2
 981 003c 07       		.byte	0x7
 982 003d 5A000000 		.4byte	.LASF3
 983 0041 02       		.uleb128 0x2
 984 0042 04       		.byte	0x4
 985 0043 05       		.byte	0x5
 986 0044 14030000 		.4byte	.LASF4
 987 0048 02       		.uleb128 0x2
 988 0049 04       		.byte	0x4
 989 004a 07       		.byte	0x7
 990 004b DE000000 		.4byte	.LASF5
 991 004f 02       		.uleb128 0x2
 992 0050 08       		.byte	0x8
 993 0051 05       		.byte	0x5
 994 0052 00000000 		.4byte	.LASF6
 995 0056 02       		.uleb128 0x2
 996 0057 08       		.byte	0x8
 997 0058 07       		.byte	0x7
 998 0059 07020000 		.4byte	.LASF7
 999 005d 03       		.uleb128 0x3
 1000 005e 04       		.byte	0x4
 1001 005f 05       		.byte	0x5
 1002 0060 696E7400 		.ascii	"int\000"
 1003 0064 02       		.uleb128 0x2
 1004 0065 04       		.byte	0x4
 1005 0066 07       		.byte	0x7
 1006 0067 E3010000 		.4byte	.LASF8
 1007 006b 04       		.uleb128 0x4
 1008 006c F0000000 		.4byte	.LASF9
 1009 0070 02       		.byte	0x2
 1010 0071 3801     		.2byte	0x138
 1011 0073 2C000000 		.4byte	0x2c
 1012 0077 04       		.uleb128 0x4
 1013 0078 CD010000 		.4byte	.LASF10
 1014 007c 02       		.byte	0x2
 1015 007d 3901     		.2byte	0x139
 1016 007f 3A000000 		.4byte	0x3a
 1017 0083 02       		.uleb128 0x2
 1018 0084 04       		.byte	0x4
 1019 0085 04       		.byte	0x4
 1020 0086 A0000000 		.4byte	.LASF11
 1021 008a 02       		.uleb128 0x2
 1022 008b 08       		.byte	0x8
 1023 008c 04       		.byte	0x4
 1024 008d B5010000 		.4byte	.LASF12
 1025 0091 04       		.uleb128 0x4
 1026 0092 4C000000 		.4byte	.LASF13
 1027 0096 02       		.byte	0x2
 1028 0097 4901     		.2byte	0x149
 1029 0099 9D000000 		.4byte	0x9d
 1030 009d 02       		.uleb128 0x2
 1031 009e 01       		.byte	0x1
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 47


 1032 009f 08       		.byte	0x8
 1033 00a0 AE020000 		.4byte	.LASF14
 1034 00a4 04       		.uleb128 0x4
 1035 00a5 B2000000 		.4byte	.LASF15
 1036 00a9 02       		.byte	0x2
 1037 00aa E201     		.2byte	0x1e2
 1038 00ac B0000000 		.4byte	0xb0
 1039 00b0 05       		.uleb128 0x5
 1040 00b1 6B000000 		.4byte	0x6b
 1041 00b5 02       		.uleb128 0x2
 1042 00b6 04       		.byte	0x4
 1043 00b7 07       		.byte	0x7
 1044 00b8 57020000 		.4byte	.LASF16
 1045 00bc 06       		.uleb128 0x6
 1046 00bd 1A000000 		.4byte	.LASF17
 1047 00c1 01       		.byte	0x1
 1048 00c2 4C       		.byte	0x4c
 1049 00c3 00000000 		.4byte	.LFB0
 1050 00c7 20000000 		.4byte	.LFE0-.LFB0
 1051 00cb 01       		.uleb128 0x1
 1052 00cc 9C       		.byte	0x9c
 1053 00cd 07       		.uleb128 0x7
 1054 00ce 0E000000 		.4byte	.LASF18
 1055 00d2 01       		.byte	0x1
 1056 00d3 6A       		.byte	0x6a
 1057 00d4 00000000 		.4byte	.LFB1
 1058 00d8 20000000 		.4byte	.LFE1-.LFB1
 1059 00dc 01       		.uleb128 0x1
 1060 00dd 9C       		.byte	0x9c
 1061 00de 08       		.uleb128 0x8
 1062 00df 37030000 		.4byte	.LASF19
 1063 00e3 01       		.byte	0x1
 1064 00e4 B7       		.byte	0xb7
 1065 00e5 00000000 		.4byte	.LFB2
 1066 00e9 44000000 		.4byte	.LFE2-.LFB2
 1067 00ed 01       		.uleb128 0x1
 1068 00ee 9C       		.byte	0x9c
 1069 00ef 02010000 		.4byte	0x102
 1070 00f3 09       		.uleb128 0x9
 1071 00f4 08010000 		.4byte	.LASF21
 1072 00f8 01       		.byte	0x1
 1073 00f9 B9       		.byte	0xb9
 1074 00fa 6B000000 		.4byte	0x6b
 1075 00fe 02       		.uleb128 0x2
 1076 00ff 91       		.byte	0x91
 1077 0100 77       		.sleb128 -9
 1078 0101 00       		.byte	0
 1079 0102 08       		.uleb128 0x8
 1080 0103 D2000000 		.4byte	.LASF20
 1081 0107 01       		.byte	0x1
 1082 0108 F0       		.byte	0xf0
 1083 0109 00000000 		.4byte	.LFB3
 1084 010d 44000000 		.4byte	.LFE3-.LFB3
 1085 0111 01       		.uleb128 0x1
 1086 0112 9C       		.byte	0x9c
 1087 0113 26010000 		.4byte	0x126
 1088 0117 09       		.uleb128 0x9
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 48


 1089 0118 08010000 		.4byte	.LASF21
 1090 011c 01       		.byte	0x1
 1091 011d F2       		.byte	0xf2
 1092 011e 6B000000 		.4byte	0x6b
 1093 0122 02       		.uleb128 0x2
 1094 0123 91       		.byte	0x91
 1095 0124 77       		.sleb128 -9
 1096 0125 00       		.byte	0
 1097 0126 0A       		.uleb128 0xa
 1098 0127 B7000000 		.4byte	.LASF28
 1099 012b 01       		.byte	0x1
 1100 012c 2701     		.2byte	0x127
 1101 012e 6B000000 		.4byte	0x6b
 1102 0132 00000000 		.4byte	.LFB4
 1103 0136 10000000 		.4byte	.LFE4-.LFB4
 1104 013a 01       		.uleb128 0x1
 1105 013b 9C       		.byte	0x9c
 1106 013c 0B       		.uleb128 0xb
 1107 013d 27000000 		.4byte	.LASF22
 1108 0141 01       		.byte	0x1
 1109 0142 3F01     		.2byte	0x13f
 1110 0144 00000000 		.4byte	.LFB5
 1111 0148 14000000 		.4byte	.LFE5-.LFB5
 1112 014c 01       		.uleb128 0x1
 1113 014d 9C       		.byte	0x9c
 1114 014e 62010000 		.4byte	0x162
 1115 0152 0C       		.uleb128 0xc
 1116 0153 F6000000 		.4byte	.LASF24
 1117 0157 01       		.byte	0x1
 1118 0158 3F01     		.2byte	0x13f
 1119 015a 6B000000 		.4byte	0x6b
 1120 015e 02       		.uleb128 0x2
 1121 015f 91       		.byte	0x91
 1122 0160 77       		.sleb128 -9
 1123 0161 00       		.byte	0
 1124 0162 0B       		.uleb128 0xb
 1125 0163 1D030000 		.4byte	.LASF23
 1126 0167 01       		.byte	0x1
 1127 0168 8C03     		.2byte	0x38c
 1128 016a 00000000 		.4byte	.LFB6
 1129 016e 20000000 		.4byte	.LFE6-.LFB6
 1130 0172 01       		.uleb128 0x1
 1131 0173 9C       		.byte	0x9c
 1132 0174 88010000 		.4byte	0x188
 1133 0178 0C       		.uleb128 0xc
 1134 0179 BC010000 		.4byte	.LASF25
 1135 017d 01       		.byte	0x1
 1136 017e 8C03     		.2byte	0x38c
 1137 0180 6B000000 		.4byte	0x6b
 1138 0184 02       		.uleb128 0x2
 1139 0185 91       		.byte	0x91
 1140 0186 77       		.sleb128 -9
 1141 0187 00       		.byte	0
 1142 0188 0B       		.uleb128 0xb
 1143 0189 DD020000 		.4byte	.LASF26
 1144 018d 01       		.byte	0x1
 1145 018e AE03     		.2byte	0x3ae
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 49


 1146 0190 00000000 		.4byte	.LFB7
 1147 0194 2C000000 		.4byte	.LFE7-.LFB7
 1148 0198 01       		.uleb128 0x1
 1149 0199 9C       		.byte	0x9c
 1150 019a AE010000 		.4byte	0x1ae
 1151 019e 0C       		.uleb128 0xc
 1152 019f A3020000 		.4byte	.LASF27
 1153 01a3 01       		.byte	0x1
 1154 01a4 AE03     		.2byte	0x3ae
 1155 01a6 6B000000 		.4byte	0x6b
 1156 01aa 02       		.uleb128 0x2
 1157 01ab 91       		.byte	0x91
 1158 01ac 77       		.sleb128 -9
 1159 01ad 00       		.byte	0
 1160 01ae 0A       		.uleb128 0xa
 1161 01af 85000000 		.4byte	.LASF29
 1162 01b3 01       		.byte	0x1
 1163 01b4 EB03     		.2byte	0x3eb
 1164 01b6 6B000000 		.4byte	0x6b
 1165 01ba 00000000 		.4byte	.LFB8
 1166 01be 18000000 		.4byte	.LFE8-.LFB8
 1167 01c2 01       		.uleb128 0x1
 1168 01c3 9C       		.byte	0x9c
 1169 01c4 0B       		.uleb128 0xb
 1170 01c5 D4010000 		.4byte	.LASF30
 1171 01c9 01       		.byte	0x1
 1172 01ca 1104     		.2byte	0x411
 1173 01cc 00000000 		.4byte	.LFB9
 1174 01d0 34000000 		.4byte	.LFE9-.LFB9
 1175 01d4 01       		.uleb128 0x1
 1176 01d5 9C       		.byte	0x9c
 1177 01d6 EA010000 		.4byte	0x1ea
 1178 01da 0C       		.uleb128 0xc
 1179 01db A3020000 		.4byte	.LASF27
 1180 01df 01       		.byte	0x1
 1181 01e0 1104     		.2byte	0x411
 1182 01e2 6B000000 		.4byte	0x6b
 1183 01e6 02       		.uleb128 0x2
 1184 01e7 91       		.byte	0x91
 1185 01e8 77       		.sleb128 -9
 1186 01e9 00       		.byte	0
 1187 01ea 0D       		.uleb128 0xd
 1188 01eb 51030000 		.4byte	.LASF31
 1189 01ef 01       		.byte	0x1
 1190 01f0 7904     		.2byte	0x479
 1191 01f2 00000000 		.4byte	.LFB10
 1192 01f6 40000000 		.4byte	.LFE10-.LFB10
 1193 01fa 01       		.uleb128 0x1
 1194 01fb 9C       		.byte	0x9c
 1195 01fc 1F020000 		.4byte	0x21f
 1196 0200 0C       		.uleb128 0xc
 1197 0201 99000000 		.4byte	.LASF32
 1198 0205 01       		.byte	0x1
 1199 0206 7904     		.2byte	0x479
 1200 0208 1F020000 		.4byte	0x21f
 1201 020c 02       		.uleb128 0x2
 1202 020d 91       		.byte	0x91
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 50


 1203 020e 6C       		.sleb128 -20
 1204 020f 0E       		.uleb128 0xe
 1205 0210 2D020000 		.4byte	.LASF33
 1206 0214 01       		.byte	0x1
 1207 0215 7B04     		.2byte	0x47b
 1208 0217 77000000 		.4byte	0x77
 1209 021b 02       		.uleb128 0x2
 1210 021c 91       		.byte	0x91
 1211 021d 76       		.sleb128 -10
 1212 021e 00       		.byte	0
 1213 021f 0F       		.uleb128 0xf
 1214 0220 04       		.byte	0x4
 1215 0221 25020000 		.4byte	0x225
 1216 0225 10       		.uleb128 0x10
 1217 0226 91000000 		.4byte	0x91
 1218 022a 0D       		.uleb128 0xd
 1219 022b 47020000 		.4byte	.LASF34
 1220 022f 01       		.byte	0x1
 1221 0230 A704     		.2byte	0x4a7
 1222 0232 00000000 		.4byte	.LFB11
 1223 0236 40000000 		.4byte	.LFE11-.LFB11
 1224 023a 01       		.uleb128 0x1
 1225 023b 9C       		.byte	0x9c
 1226 023c 6E020000 		.4byte	0x26e
 1227 0240 0C       		.uleb128 0xc
 1228 0241 99000000 		.4byte	.LASF32
 1229 0245 01       		.byte	0x1
 1230 0246 A704     		.2byte	0x4a7
 1231 0248 6E020000 		.4byte	0x26e
 1232 024c 02       		.uleb128 0x2
 1233 024d 91       		.byte	0x91
 1234 024e 6C       		.sleb128 -20
 1235 024f 0C       		.uleb128 0xc
 1236 0250 FE000000 		.4byte	.LASF35
 1237 0254 01       		.byte	0x1
 1238 0255 A704     		.2byte	0x4a7
 1239 0257 6B000000 		.4byte	0x6b
 1240 025b 02       		.uleb128 0x2
 1241 025c 91       		.byte	0x91
 1242 025d 6B       		.sleb128 -21
 1243 025e 0E       		.uleb128 0xe
 1244 025f 2D020000 		.4byte	.LASF33
 1245 0263 01       		.byte	0x1
 1246 0264 AA04     		.2byte	0x4aa
 1247 0266 6B000000 		.4byte	0x6b
 1248 026a 02       		.uleb128 0x2
 1249 026b 91       		.byte	0x91
 1250 026c 77       		.sleb128 -9
 1251 026d 00       		.byte	0
 1252 026e 0F       		.uleb128 0xf
 1253 026f 04       		.byte	0x4
 1254 0270 74020000 		.4byte	0x274
 1255 0274 10       		.uleb128 0x10
 1256 0275 6B000000 		.4byte	0x6b
 1257 0279 0D       		.uleb128 0xd
 1258 027a 1E020000 		.4byte	.LASF36
 1259 027e 01       		.byte	0x1
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 51


 1260 027f CE04     		.2byte	0x4ce
 1261 0281 00000000 		.4byte	.LFB12
 1262 0285 30000000 		.4byte	.LFE12-.LFB12
 1263 0289 01       		.uleb128 0x1
 1264 028a 9C       		.byte	0x9c
 1265 028b 9F020000 		.4byte	0x29f
 1266 028f 0C       		.uleb128 0xc
 1267 0290 A3020000 		.4byte	.LASF27
 1268 0294 01       		.byte	0x1
 1269 0295 CE04     		.2byte	0x4ce
 1270 0297 6B000000 		.4byte	0x6b
 1271 029b 02       		.uleb128 0x2
 1272 029c 91       		.byte	0x91
 1273 029d 77       		.sleb128 -9
 1274 029e 00       		.byte	0
 1275 029f 11       		.uleb128 0x11
 1276 02a0 F0010000 		.4byte	.LASF48
 1277 02a4 01       		.byte	0x1
 1278 02a5 F904     		.2byte	0x4f9
 1279 02a7 6B000000 		.4byte	0x6b
 1280 02ab 00000000 		.4byte	.LFB13
 1281 02af 44000000 		.4byte	.LFE13-.LFB13
 1282 02b3 01       		.uleb128 0x1
 1283 02b4 9C       		.byte	0x9c
 1284 02b5 C9020000 		.4byte	0x2c9
 1285 02b9 0E       		.uleb128 0xe
 1286 02ba 62030000 		.4byte	.LASF37
 1287 02be 01       		.byte	0x1
 1288 02bf FC04     		.2byte	0x4fc
 1289 02c1 6B000000 		.4byte	0x6b
 1290 02c5 02       		.uleb128 0x2
 1291 02c6 91       		.byte	0x91
 1292 02c7 77       		.sleb128 -9
 1293 02c8 00       		.byte	0
 1294 02c9 0D       		.uleb128 0xd
 1295 02ca F0020000 		.4byte	.LASF38
 1296 02ce 01       		.byte	0x1
 1297 02cf 4A05     		.2byte	0x54a
 1298 02d1 00000000 		.4byte	.LFB14
 1299 02d5 40000000 		.4byte	.LFE14-.LFB14
 1300 02d9 01       		.uleb128 0x1
 1301 02da 9C       		.byte	0x9c
 1302 02db EF020000 		.4byte	0x2ef
 1303 02df 0E       		.uleb128 0xe
 1304 02e0 08010000 		.4byte	.LASF21
 1305 02e4 01       		.byte	0x1
 1306 02e5 4C05     		.2byte	0x54c
 1307 02e7 6B000000 		.4byte	0x6b
 1308 02eb 02       		.uleb128 0x2
 1309 02ec 91       		.byte	0x91
 1310 02ed 77       		.sleb128 -9
 1311 02ee 00       		.byte	0
 1312 02ef 0B       		.uleb128 0xb
 1313 02f0 36020000 		.4byte	.LASF39
 1314 02f4 01       		.byte	0x1
 1315 02f5 A005     		.2byte	0x5a0
 1316 02f7 00000000 		.4byte	.LFB15
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 52


 1317 02fb 9C000000 		.4byte	.LFE15-.LFB15
 1318 02ff 01       		.uleb128 0x1
 1319 0300 9C       		.byte	0x9c
 1320 0301 40030000 		.4byte	0x340
 1321 0305 0C       		.uleb128 0xc
 1322 0306 D5020000 		.4byte	.LASF40
 1323 030a 01       		.byte	0x1
 1324 030b A005     		.2byte	0x5a0
 1325 030d 6B000000 		.4byte	0x6b
 1326 0311 02       		.uleb128 0x2
 1327 0312 91       		.byte	0x91
 1328 0313 6F       		.sleb128 -17
 1329 0314 12       		.uleb128 0x12
 1330 0315 12000000 		.4byte	.LBB2
 1331 0319 6C000000 		.4byte	.LBE2-.LBB2
 1332 031d 0E       		.uleb128 0xe
 1333 031e 52000000 		.4byte	.LASF41
 1334 0322 01       		.byte	0x1
 1335 0323 A805     		.2byte	0x5a8
 1336 0325 6B000000 		.4byte	0x6b
 1337 0329 02       		.uleb128 0x2
 1338 032a 91       		.byte	0x91
 1339 032b 77       		.sleb128 -9
 1340 032c 0E       		.uleb128 0xe
 1341 032d 43000000 		.4byte	.LASF42
 1342 0331 01       		.byte	0x1
 1343 0332 D005     		.2byte	0x5d0
 1344 0334 6B000000 		.4byte	0x6b
 1345 0338 05       		.uleb128 0x5
 1346 0339 03       		.byte	0x3
 1347 033a 01000000 		.4byte	txPeriod.4914
 1348 033e 00       		.byte	0
 1349 033f 00       		.byte	0
 1350 0340 0B       		.uleb128 0xb
 1351 0341 6D000000 		.4byte	.LASF43
 1352 0345 01       		.byte	0x1
 1353 0346 2406     		.2byte	0x624
 1354 0348 00000000 		.4byte	.LFB16
 1355 034c 14000000 		.4byte	.LFE16-.LFB16
 1356 0350 01       		.uleb128 0x1
 1357 0351 9C       		.byte	0x9c
 1358 0352 66030000 		.4byte	0x366
 1359 0356 0C       		.uleb128 0xc
 1360 0357 A6000000 		.4byte	.LASF44
 1361 035b 01       		.byte	0x1
 1362 035c 2406     		.2byte	0x624
 1363 035e 6B000000 		.4byte	0x6b
 1364 0362 02       		.uleb128 0x2
 1365 0363 91       		.byte	0x91
 1366 0364 77       		.sleb128 -9
 1367 0365 00       		.byte	0
 1368 0366 13       		.uleb128 0x13
 1369 0367 05030000 		.4byte	.LASF49
 1370 036b 01       		.byte	0x1
 1371 036c 1B       		.byte	0x1b
 1372 036d 6B000000 		.4byte	0x6b
 1373 0371 05       		.uleb128 0x5
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 53


 1374 0372 03       		.byte	0x3
 1375 0373 00000000 		.4byte	UART_1_initVar
 1376 0377 00       		.byte	0
 1377              		.section	.debug_abbrev,"",%progbits
 1378              	.Ldebug_abbrev0:
 1379 0000 01       		.uleb128 0x1
 1380 0001 11       		.uleb128 0x11
 1381 0002 01       		.byte	0x1
 1382 0003 25       		.uleb128 0x25
 1383 0004 0E       		.uleb128 0xe
 1384 0005 13       		.uleb128 0x13
 1385 0006 0B       		.uleb128 0xb
 1386 0007 03       		.uleb128 0x3
 1387 0008 0E       		.uleb128 0xe
 1388 0009 1B       		.uleb128 0x1b
 1389 000a 0E       		.uleb128 0xe
 1390 000b 55       		.uleb128 0x55
 1391 000c 17       		.uleb128 0x17
 1392 000d 11       		.uleb128 0x11
 1393 000e 01       		.uleb128 0x1
 1394 000f 10       		.uleb128 0x10
 1395 0010 17       		.uleb128 0x17
 1396 0011 00       		.byte	0
 1397 0012 00       		.byte	0
 1398 0013 02       		.uleb128 0x2
 1399 0014 24       		.uleb128 0x24
 1400 0015 00       		.byte	0
 1401 0016 0B       		.uleb128 0xb
 1402 0017 0B       		.uleb128 0xb
 1403 0018 3E       		.uleb128 0x3e
 1404 0019 0B       		.uleb128 0xb
 1405 001a 03       		.uleb128 0x3
 1406 001b 0E       		.uleb128 0xe
 1407 001c 00       		.byte	0
 1408 001d 00       		.byte	0
 1409 001e 03       		.uleb128 0x3
 1410 001f 24       		.uleb128 0x24
 1411 0020 00       		.byte	0
 1412 0021 0B       		.uleb128 0xb
 1413 0022 0B       		.uleb128 0xb
 1414 0023 3E       		.uleb128 0x3e
 1415 0024 0B       		.uleb128 0xb
 1416 0025 03       		.uleb128 0x3
 1417 0026 08       		.uleb128 0x8
 1418 0027 00       		.byte	0
 1419 0028 00       		.byte	0
 1420 0029 04       		.uleb128 0x4
 1421 002a 16       		.uleb128 0x16
 1422 002b 00       		.byte	0
 1423 002c 03       		.uleb128 0x3
 1424 002d 0E       		.uleb128 0xe
 1425 002e 3A       		.uleb128 0x3a
 1426 002f 0B       		.uleb128 0xb
 1427 0030 3B       		.uleb128 0x3b
 1428 0031 05       		.uleb128 0x5
 1429 0032 49       		.uleb128 0x49
 1430 0033 13       		.uleb128 0x13
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 54


 1431 0034 00       		.byte	0
 1432 0035 00       		.byte	0
 1433 0036 05       		.uleb128 0x5
 1434 0037 35       		.uleb128 0x35
 1435 0038 00       		.byte	0
 1436 0039 49       		.uleb128 0x49
 1437 003a 13       		.uleb128 0x13
 1438 003b 00       		.byte	0
 1439 003c 00       		.byte	0
 1440 003d 06       		.uleb128 0x6
 1441 003e 2E       		.uleb128 0x2e
 1442 003f 00       		.byte	0
 1443 0040 3F       		.uleb128 0x3f
 1444 0041 19       		.uleb128 0x19
 1445 0042 03       		.uleb128 0x3
 1446 0043 0E       		.uleb128 0xe
 1447 0044 3A       		.uleb128 0x3a
 1448 0045 0B       		.uleb128 0xb
 1449 0046 3B       		.uleb128 0x3b
 1450 0047 0B       		.uleb128 0xb
 1451 0048 27       		.uleb128 0x27
 1452 0049 19       		.uleb128 0x19
 1453 004a 11       		.uleb128 0x11
 1454 004b 01       		.uleb128 0x1
 1455 004c 12       		.uleb128 0x12
 1456 004d 06       		.uleb128 0x6
 1457 004e 40       		.uleb128 0x40
 1458 004f 18       		.uleb128 0x18
 1459 0050 9642     		.uleb128 0x2116
 1460 0052 19       		.uleb128 0x19
 1461 0053 00       		.byte	0
 1462 0054 00       		.byte	0
 1463 0055 07       		.uleb128 0x7
 1464 0056 2E       		.uleb128 0x2e
 1465 0057 00       		.byte	0
 1466 0058 3F       		.uleb128 0x3f
 1467 0059 19       		.uleb128 0x19
 1468 005a 03       		.uleb128 0x3
 1469 005b 0E       		.uleb128 0xe
 1470 005c 3A       		.uleb128 0x3a
 1471 005d 0B       		.uleb128 0xb
 1472 005e 3B       		.uleb128 0x3b
 1473 005f 0B       		.uleb128 0xb
 1474 0060 27       		.uleb128 0x27
 1475 0061 19       		.uleb128 0x19
 1476 0062 11       		.uleb128 0x11
 1477 0063 01       		.uleb128 0x1
 1478 0064 12       		.uleb128 0x12
 1479 0065 06       		.uleb128 0x6
 1480 0066 40       		.uleb128 0x40
 1481 0067 18       		.uleb128 0x18
 1482 0068 9742     		.uleb128 0x2117
 1483 006a 19       		.uleb128 0x19
 1484 006b 00       		.byte	0
 1485 006c 00       		.byte	0
 1486 006d 08       		.uleb128 0x8
 1487 006e 2E       		.uleb128 0x2e
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 55


 1488 006f 01       		.byte	0x1
 1489 0070 3F       		.uleb128 0x3f
 1490 0071 19       		.uleb128 0x19
 1491 0072 03       		.uleb128 0x3
 1492 0073 0E       		.uleb128 0xe
 1493 0074 3A       		.uleb128 0x3a
 1494 0075 0B       		.uleb128 0xb
 1495 0076 3B       		.uleb128 0x3b
 1496 0077 0B       		.uleb128 0xb
 1497 0078 27       		.uleb128 0x27
 1498 0079 19       		.uleb128 0x19
 1499 007a 11       		.uleb128 0x11
 1500 007b 01       		.uleb128 0x1
 1501 007c 12       		.uleb128 0x12
 1502 007d 06       		.uleb128 0x6
 1503 007e 40       		.uleb128 0x40
 1504 007f 18       		.uleb128 0x18
 1505 0080 9642     		.uleb128 0x2116
 1506 0082 19       		.uleb128 0x19
 1507 0083 01       		.uleb128 0x1
 1508 0084 13       		.uleb128 0x13
 1509 0085 00       		.byte	0
 1510 0086 00       		.byte	0
 1511 0087 09       		.uleb128 0x9
 1512 0088 34       		.uleb128 0x34
 1513 0089 00       		.byte	0
 1514 008a 03       		.uleb128 0x3
 1515 008b 0E       		.uleb128 0xe
 1516 008c 3A       		.uleb128 0x3a
 1517 008d 0B       		.uleb128 0xb
 1518 008e 3B       		.uleb128 0x3b
 1519 008f 0B       		.uleb128 0xb
 1520 0090 49       		.uleb128 0x49
 1521 0091 13       		.uleb128 0x13
 1522 0092 02       		.uleb128 0x2
 1523 0093 18       		.uleb128 0x18
 1524 0094 00       		.byte	0
 1525 0095 00       		.byte	0
 1526 0096 0A       		.uleb128 0xa
 1527 0097 2E       		.uleb128 0x2e
 1528 0098 00       		.byte	0
 1529 0099 3F       		.uleb128 0x3f
 1530 009a 19       		.uleb128 0x19
 1531 009b 03       		.uleb128 0x3
 1532 009c 0E       		.uleb128 0xe
 1533 009d 3A       		.uleb128 0x3a
 1534 009e 0B       		.uleb128 0xb
 1535 009f 3B       		.uleb128 0x3b
 1536 00a0 05       		.uleb128 0x5
 1537 00a1 27       		.uleb128 0x27
 1538 00a2 19       		.uleb128 0x19
 1539 00a3 49       		.uleb128 0x49
 1540 00a4 13       		.uleb128 0x13
 1541 00a5 11       		.uleb128 0x11
 1542 00a6 01       		.uleb128 0x1
 1543 00a7 12       		.uleb128 0x12
 1544 00a8 06       		.uleb128 0x6
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 56


 1545 00a9 40       		.uleb128 0x40
 1546 00aa 18       		.uleb128 0x18
 1547 00ab 9742     		.uleb128 0x2117
 1548 00ad 19       		.uleb128 0x19
 1549 00ae 00       		.byte	0
 1550 00af 00       		.byte	0
 1551 00b0 0B       		.uleb128 0xb
 1552 00b1 2E       		.uleb128 0x2e
 1553 00b2 01       		.byte	0x1
 1554 00b3 3F       		.uleb128 0x3f
 1555 00b4 19       		.uleb128 0x19
 1556 00b5 03       		.uleb128 0x3
 1557 00b6 0E       		.uleb128 0xe
 1558 00b7 3A       		.uleb128 0x3a
 1559 00b8 0B       		.uleb128 0xb
 1560 00b9 3B       		.uleb128 0x3b
 1561 00ba 05       		.uleb128 0x5
 1562 00bb 27       		.uleb128 0x27
 1563 00bc 19       		.uleb128 0x19
 1564 00bd 11       		.uleb128 0x11
 1565 00be 01       		.uleb128 0x1
 1566 00bf 12       		.uleb128 0x12
 1567 00c0 06       		.uleb128 0x6
 1568 00c1 40       		.uleb128 0x40
 1569 00c2 18       		.uleb128 0x18
 1570 00c3 9742     		.uleb128 0x2117
 1571 00c5 19       		.uleb128 0x19
 1572 00c6 01       		.uleb128 0x1
 1573 00c7 13       		.uleb128 0x13
 1574 00c8 00       		.byte	0
 1575 00c9 00       		.byte	0
 1576 00ca 0C       		.uleb128 0xc
 1577 00cb 05       		.uleb128 0x5
 1578 00cc 00       		.byte	0
 1579 00cd 03       		.uleb128 0x3
 1580 00ce 0E       		.uleb128 0xe
 1581 00cf 3A       		.uleb128 0x3a
 1582 00d0 0B       		.uleb128 0xb
 1583 00d1 3B       		.uleb128 0x3b
 1584 00d2 05       		.uleb128 0x5
 1585 00d3 49       		.uleb128 0x49
 1586 00d4 13       		.uleb128 0x13
 1587 00d5 02       		.uleb128 0x2
 1588 00d6 18       		.uleb128 0x18
 1589 00d7 00       		.byte	0
 1590 00d8 00       		.byte	0
 1591 00d9 0D       		.uleb128 0xd
 1592 00da 2E       		.uleb128 0x2e
 1593 00db 01       		.byte	0x1
 1594 00dc 3F       		.uleb128 0x3f
 1595 00dd 19       		.uleb128 0x19
 1596 00de 03       		.uleb128 0x3
 1597 00df 0E       		.uleb128 0xe
 1598 00e0 3A       		.uleb128 0x3a
 1599 00e1 0B       		.uleb128 0xb
 1600 00e2 3B       		.uleb128 0x3b
 1601 00e3 05       		.uleb128 0x5
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 57


 1602 00e4 27       		.uleb128 0x27
 1603 00e5 19       		.uleb128 0x19
 1604 00e6 11       		.uleb128 0x11
 1605 00e7 01       		.uleb128 0x1
 1606 00e8 12       		.uleb128 0x12
 1607 00e9 06       		.uleb128 0x6
 1608 00ea 40       		.uleb128 0x40
 1609 00eb 18       		.uleb128 0x18
 1610 00ec 9642     		.uleb128 0x2116
 1611 00ee 19       		.uleb128 0x19
 1612 00ef 01       		.uleb128 0x1
 1613 00f0 13       		.uleb128 0x13
 1614 00f1 00       		.byte	0
 1615 00f2 00       		.byte	0
 1616 00f3 0E       		.uleb128 0xe
 1617 00f4 34       		.uleb128 0x34
 1618 00f5 00       		.byte	0
 1619 00f6 03       		.uleb128 0x3
 1620 00f7 0E       		.uleb128 0xe
 1621 00f8 3A       		.uleb128 0x3a
 1622 00f9 0B       		.uleb128 0xb
 1623 00fa 3B       		.uleb128 0x3b
 1624 00fb 05       		.uleb128 0x5
 1625 00fc 49       		.uleb128 0x49
 1626 00fd 13       		.uleb128 0x13
 1627 00fe 02       		.uleb128 0x2
 1628 00ff 18       		.uleb128 0x18
 1629 0100 00       		.byte	0
 1630 0101 00       		.byte	0
 1631 0102 0F       		.uleb128 0xf
 1632 0103 0F       		.uleb128 0xf
 1633 0104 00       		.byte	0
 1634 0105 0B       		.uleb128 0xb
 1635 0106 0B       		.uleb128 0xb
 1636 0107 49       		.uleb128 0x49
 1637 0108 13       		.uleb128 0x13
 1638 0109 00       		.byte	0
 1639 010a 00       		.byte	0
 1640 010b 10       		.uleb128 0x10
 1641 010c 26       		.uleb128 0x26
 1642 010d 00       		.byte	0
 1643 010e 49       		.uleb128 0x49
 1644 010f 13       		.uleb128 0x13
 1645 0110 00       		.byte	0
 1646 0111 00       		.byte	0
 1647 0112 11       		.uleb128 0x11
 1648 0113 2E       		.uleb128 0x2e
 1649 0114 01       		.byte	0x1
 1650 0115 3F       		.uleb128 0x3f
 1651 0116 19       		.uleb128 0x19
 1652 0117 03       		.uleb128 0x3
 1653 0118 0E       		.uleb128 0xe
 1654 0119 3A       		.uleb128 0x3a
 1655 011a 0B       		.uleb128 0xb
 1656 011b 3B       		.uleb128 0x3b
 1657 011c 05       		.uleb128 0x5
 1658 011d 27       		.uleb128 0x27
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 58


 1659 011e 19       		.uleb128 0x19
 1660 011f 49       		.uleb128 0x49
 1661 0120 13       		.uleb128 0x13
 1662 0121 11       		.uleb128 0x11
 1663 0122 01       		.uleb128 0x1
 1664 0123 12       		.uleb128 0x12
 1665 0124 06       		.uleb128 0x6
 1666 0125 40       		.uleb128 0x40
 1667 0126 18       		.uleb128 0x18
 1668 0127 9742     		.uleb128 0x2117
 1669 0129 19       		.uleb128 0x19
 1670 012a 01       		.uleb128 0x1
 1671 012b 13       		.uleb128 0x13
 1672 012c 00       		.byte	0
 1673 012d 00       		.byte	0
 1674 012e 12       		.uleb128 0x12
 1675 012f 0B       		.uleb128 0xb
 1676 0130 01       		.byte	0x1
 1677 0131 11       		.uleb128 0x11
 1678 0132 01       		.uleb128 0x1
 1679 0133 12       		.uleb128 0x12
 1680 0134 06       		.uleb128 0x6
 1681 0135 00       		.byte	0
 1682 0136 00       		.byte	0
 1683 0137 13       		.uleb128 0x13
 1684 0138 34       		.uleb128 0x34
 1685 0139 00       		.byte	0
 1686 013a 03       		.uleb128 0x3
 1687 013b 0E       		.uleb128 0xe
 1688 013c 3A       		.uleb128 0x3a
 1689 013d 0B       		.uleb128 0xb
 1690 013e 3B       		.uleb128 0x3b
 1691 013f 0B       		.uleb128 0xb
 1692 0140 49       		.uleb128 0x49
 1693 0141 13       		.uleb128 0x13
 1694 0142 3F       		.uleb128 0x3f
 1695 0143 19       		.uleb128 0x19
 1696 0144 02       		.uleb128 0x2
 1697 0145 18       		.uleb128 0x18
 1698 0146 00       		.byte	0
 1699 0147 00       		.byte	0
 1700 0148 00       		.byte	0
 1701              		.section	.debug_aranges,"",%progbits
 1702 0000 9C000000 		.4byte	0x9c
 1703 0004 0200     		.2byte	0x2
 1704 0006 00000000 		.4byte	.Ldebug_info0
 1705 000a 04       		.byte	0x4
 1706 000b 00       		.byte	0
 1707 000c 0000     		.2byte	0
 1708 000e 0000     		.2byte	0
 1709 0010 00000000 		.4byte	.LFB0
 1710 0014 20000000 		.4byte	.LFE0-.LFB0
 1711 0018 00000000 		.4byte	.LFB1
 1712 001c 20000000 		.4byte	.LFE1-.LFB1
 1713 0020 00000000 		.4byte	.LFB2
 1714 0024 44000000 		.4byte	.LFE2-.LFB2
 1715 0028 00000000 		.4byte	.LFB3
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 59


 1716 002c 44000000 		.4byte	.LFE3-.LFB3
 1717 0030 00000000 		.4byte	.LFB4
 1718 0034 10000000 		.4byte	.LFE4-.LFB4
 1719 0038 00000000 		.4byte	.LFB5
 1720 003c 14000000 		.4byte	.LFE5-.LFB5
 1721 0040 00000000 		.4byte	.LFB6
 1722 0044 20000000 		.4byte	.LFE6-.LFB6
 1723 0048 00000000 		.4byte	.LFB7
 1724 004c 2C000000 		.4byte	.LFE7-.LFB7
 1725 0050 00000000 		.4byte	.LFB8
 1726 0054 18000000 		.4byte	.LFE8-.LFB8
 1727 0058 00000000 		.4byte	.LFB9
 1728 005c 34000000 		.4byte	.LFE9-.LFB9
 1729 0060 00000000 		.4byte	.LFB10
 1730 0064 40000000 		.4byte	.LFE10-.LFB10
 1731 0068 00000000 		.4byte	.LFB11
 1732 006c 40000000 		.4byte	.LFE11-.LFB11
 1733 0070 00000000 		.4byte	.LFB12
 1734 0074 30000000 		.4byte	.LFE12-.LFB12
 1735 0078 00000000 		.4byte	.LFB13
 1736 007c 44000000 		.4byte	.LFE13-.LFB13
 1737 0080 00000000 		.4byte	.LFB14
 1738 0084 40000000 		.4byte	.LFE14-.LFB14
 1739 0088 00000000 		.4byte	.LFB15
 1740 008c 9C000000 		.4byte	.LFE15-.LFB15
 1741 0090 00000000 		.4byte	.LFB16
 1742 0094 14000000 		.4byte	.LFE16-.LFB16
 1743 0098 00000000 		.4byte	0
 1744 009c 00000000 		.4byte	0
 1745              		.section	.debug_ranges,"",%progbits
 1746              	.Ldebug_ranges0:
 1747 0000 00000000 		.4byte	.LFB0
 1748 0004 20000000 		.4byte	.LFE0
 1749 0008 00000000 		.4byte	.LFB1
 1750 000c 20000000 		.4byte	.LFE1
 1751 0010 00000000 		.4byte	.LFB2
 1752 0014 44000000 		.4byte	.LFE2
 1753 0018 00000000 		.4byte	.LFB3
 1754 001c 44000000 		.4byte	.LFE3
 1755 0020 00000000 		.4byte	.LFB4
 1756 0024 10000000 		.4byte	.LFE4
 1757 0028 00000000 		.4byte	.LFB5
 1758 002c 14000000 		.4byte	.LFE5
 1759 0030 00000000 		.4byte	.LFB6
 1760 0034 20000000 		.4byte	.LFE6
 1761 0038 00000000 		.4byte	.LFB7
 1762 003c 2C000000 		.4byte	.LFE7
 1763 0040 00000000 		.4byte	.LFB8
 1764 0044 18000000 		.4byte	.LFE8
 1765 0048 00000000 		.4byte	.LFB9
 1766 004c 34000000 		.4byte	.LFE9
 1767 0050 00000000 		.4byte	.LFB10
 1768 0054 40000000 		.4byte	.LFE10
 1769 0058 00000000 		.4byte	.LFB11
 1770 005c 40000000 		.4byte	.LFE11
 1771 0060 00000000 		.4byte	.LFB12
 1772 0064 30000000 		.4byte	.LFE12
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 60


 1773 0068 00000000 		.4byte	.LFB13
 1774 006c 44000000 		.4byte	.LFE13
 1775 0070 00000000 		.4byte	.LFB14
 1776 0074 40000000 		.4byte	.LFE14
 1777 0078 00000000 		.4byte	.LFB15
 1778 007c 9C000000 		.4byte	.LFE15
 1779 0080 00000000 		.4byte	.LFB16
 1780 0084 14000000 		.4byte	.LFE16
 1781 0088 00000000 		.4byte	0
 1782 008c 00000000 		.4byte	0
 1783              		.section	.debug_line,"",%progbits
 1784              	.Ldebug_line0:
 1785 0000 F4010000 		.section	.debug_str,"MS",%progbits,1
 1785      02004500 
 1785      00000201 
 1785      FB0E0D00 
 1785      01010101 
 1786              	.LASF6:
 1787 0000 6C6F6E67 		.ascii	"long long int\000"
 1787      206C6F6E 
 1787      6720696E 
 1787      7400
 1788              	.LASF18:
 1789 000e 55415254 		.ascii	"UART_1_Init\000"
 1789      5F315F49 
 1789      6E697400 
 1790              	.LASF17:
 1791 001a 55415254 		.ascii	"UART_1_Start\000"
 1791      5F315F53 
 1791      74617274 
 1791      00
 1792              	.LASF22:
 1793 0027 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 1793      5F315F57 
 1793      72697465 
 1793      436F6E74 
 1793      726F6C52 
 1794              	.LASF42:
 1795 0043 74785065 		.ascii	"txPeriod\000"
 1795      72696F64 
 1795      00
 1796              	.LASF13:
 1797 004c 63686172 		.ascii	"char8\000"
 1797      3800
 1798              	.LASF41:
 1799 0052 746D7053 		.ascii	"tmpStat\000"
 1799      74617400 
 1800              	.LASF3:
 1801 005a 73686F72 		.ascii	"short unsigned int\000"
 1801      7420756E 
 1801      7369676E 
 1801      65642069 
 1801      6E7400
 1802              	.LASF43:
 1803 006d 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 1803      5F315F53 
 1803      65745478 
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 61


 1803      41646472 
 1803      6573734D 
 1804              	.LASF29:
 1805 0085 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 1805      5F315F52 
 1805      65616454 
 1805      78537461 
 1805      74757300 
 1806              	.LASF32:
 1807 0099 73747269 		.ascii	"string\000"
 1807      6E6700
 1808              	.LASF11:
 1809 00a0 666C6F61 		.ascii	"float\000"
 1809      7400
 1810              	.LASF44:
 1811 00a6 61646472 		.ascii	"addressMode\000"
 1811      6573734D 
 1811      6F646500 
 1812              	.LASF15:
 1813 00b2 72656738 		.ascii	"reg8\000"
 1813      00
 1814              	.LASF28:
 1815 00b7 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 1815      5F315F52 
 1815      65616443 
 1815      6F6E7472 
 1815      6F6C5265 
 1816              	.LASF20:
 1817 00d2 55415254 		.ascii	"UART_1_Stop\000"
 1817      5F315F53 
 1817      746F7000 
 1818              	.LASF5:
 1819 00de 6C6F6E67 		.ascii	"long unsigned int\000"
 1819      20756E73 
 1819      69676E65 
 1819      6420696E 
 1819      7400
 1820              	.LASF9:
 1821 00f0 75696E74 		.ascii	"uint8\000"
 1821      3800
 1822              	.LASF24:
 1823 00f6 636F6E74 		.ascii	"control\000"
 1823      726F6C00 
 1824              	.LASF35:
 1825 00fe 62797465 		.ascii	"byteCount\000"
 1825      436F756E 
 1825      7400
 1826              	.LASF21:
 1827 0108 656E6162 		.ascii	"enableInterrupts\000"
 1827      6C65496E 
 1827      74657272 
 1827      75707473 
 1827      00
 1828              	.LASF1:
 1829 0119 756E7369 		.ascii	"unsigned char\000"
 1829      676E6564 
 1829      20636861 
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 62


 1829      7200
 1830              	.LASF45:
 1831 0127 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 1831      4320342E 
 1831      392E3320 
 1831      32303135 
 1831      30333033 
 1832 015a 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 1832      20726576 
 1832      6973696F 
 1832      6E203232 
 1832      31323230 
 1833 018d 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 1833      66756E63 
 1833      74696F6E 
 1833      2D736563 
 1833      74696F6E 
 1834              	.LASF12:
 1835 01b5 646F7562 		.ascii	"double\000"
 1835      6C6500
 1836              	.LASF25:
 1837 01bc 696E7453 		.ascii	"intSrc\000"
 1837      726300
 1838              	.LASF2:
 1839 01c3 73686F72 		.ascii	"short int\000"
 1839      7420696E 
 1839      7400
 1840              	.LASF10:
 1841 01cd 75696E74 		.ascii	"uint16\000"
 1841      313600
 1842              	.LASF30:
 1843 01d4 55415254 		.ascii	"UART_1_PutChar\000"
 1843      5F315F50 
 1843      75744368 
 1843      617200
 1844              	.LASF8:
 1845 01e3 756E7369 		.ascii	"unsigned int\000"
 1845      676E6564 
 1845      20696E74 
 1845      00
 1846              	.LASF48:
 1847 01f0 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 1847      5F315F47 
 1847      65745478 
 1847      42756666 
 1847      65725369 
 1848              	.LASF7:
 1849 0207 6C6F6E67 		.ascii	"long long unsigned int\000"
 1849      206C6F6E 
 1849      6720756E 
 1849      7369676E 
 1849      65642069 
 1850              	.LASF36:
 1851 021e 55415254 		.ascii	"UART_1_PutCRLF\000"
 1851      5F315F50 
 1851      75744352 
 1851      4C4600
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 63


 1852              	.LASF33:
 1853 022d 62756649 		.ascii	"bufIndex\000"
 1853      6E646578 
 1853      00
 1854              	.LASF39:
 1855 0236 55415254 		.ascii	"UART_1_SendBreak\000"
 1855      5F315F53 
 1855      656E6442 
 1855      7265616B 
 1855      00
 1856              	.LASF34:
 1857 0247 55415254 		.ascii	"UART_1_PutArray\000"
 1857      5F315F50 
 1857      75744172 
 1857      72617900 
 1858              	.LASF16:
 1859 0257 73697A65 		.ascii	"sizetype\000"
 1859      74797065 
 1859      00
 1860              	.LASF47:
 1861 0260 433A5C55 		.ascii	"C:\\Users\\jthem\\Documents\\PSoC Creator\\PWMExamp"
 1861      73657273 
 1861      5C6A7468 
 1861      656D5C44 
 1861      6F63756D 
 1862 028e 6C653031 		.ascii	"le01\\UART_Tx01.cydsn\000"
 1862      5C554152 
 1862      545F5478 
 1862      30312E63 
 1862      7964736E 
 1863              	.LASF27:
 1864 02a3 74784461 		.ascii	"txDataByte\000"
 1864      74614279 
 1864      746500
 1865              	.LASF14:
 1866 02ae 63686172 		.ascii	"char\000"
 1866      00
 1867              	.LASF46:
 1868 02b3 2E5C4765 		.ascii	".\\Generated_Source\\PSoC5\\UART_1.c\000"
 1868      6E657261 
 1868      7465645F 
 1868      536F7572 
 1868      63655C50 
 1869              	.LASF40:
 1870 02d5 7265744D 		.ascii	"retMode\000"
 1870      6F646500 
 1871              	.LASF26:
 1872 02dd 55415254 		.ascii	"UART_1_WriteTxData\000"
 1872      5F315F57 
 1872      72697465 
 1872      54784461 
 1872      746100
 1873              	.LASF38:
 1874 02f0 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 1874      5F315F43 
 1874      6C656172 
 1874      54784275 
ARM GAS  C:\Users\jthem\AppData\Local\Temp\ccLHKfOB.s 			page 64


 1874      66666572 
 1875              	.LASF49:
 1876 0305 55415254 		.ascii	"UART_1_initVar\000"
 1876      5F315F69 
 1876      6E697456 
 1876      617200
 1877              	.LASF4:
 1878 0314 6C6F6E67 		.ascii	"long int\000"
 1878      20696E74 
 1878      00
 1879              	.LASF23:
 1880 031d 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 1880      5F315F53 
 1880      65745478 
 1880      496E7465 
 1880      72727570 
 1881              	.LASF19:
 1882 0337 55415254 		.ascii	"UART_1_Enable\000"
 1882      5F315F45 
 1882      6E61626C 
 1882      6500
 1883              	.LASF0:
 1884 0345 7369676E 		.ascii	"signed char\000"
 1884      65642063 
 1884      68617200 
 1885              	.LASF31:
 1886 0351 55415254 		.ascii	"UART_1_PutString\000"
 1886      5F315F50 
 1886      75745374 
 1886      72696E67 
 1886      00
 1887              	.LASF37:
 1888 0362 73697A65 		.ascii	"size\000"
 1888      00
 1889              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
